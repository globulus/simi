# Comment
#* multiline comments
span
multiple lines *#

import native "Date"

class Object {

}

class Function

class Class

class Exception {
    init(@message)
}

class TypeMismatchException is Exception {
    init {
        super.init("tme")
    }
}

class IllegalArgumentException is Exception

class Range {
    init(@min, @max)

    def iterate() = Range.Iterator(self)

    def has(o) = o >= @min and o <= @max

    class Iterator {
        init(@range) {
            self.current = range.min
        }

        def next() = if @current <= @range.max {
                @current = @current + 1
                @current - 1
            } else {
                nil
            }
    }
}

class Num {
    def rangeTo(lim) = Range(@_, lim)

    def rangeUntil(lim) = Range(@_, lim - 1)

    def equals(o) = (o is Num and @_ == o._)

    def matches(o) = if self == o {
        @_
    } else {
        nil
    }
}

class String

class List {
    native get(key)
    native set(key, value)
}

class Date {
    native init
    native at(time = 0)
}

def test(title, expected, proc) {
    r = proc()
    print "Testing \(title): " + (if r == expected "SUCCESS" else "FAIL got \(r) expected \(expected)")
}

a = 5
b = a + 3
a $= b - 4 / (2 + 2 * 2)
b /= 2
test("a is", 7.333333333333333, a)
test("b is", 4, b)
test("if", "a", =if a < 2 or a < 10 {
    "a"
} else if b == 4 {
    "b"
} else {
    "both are false"
})
test("nil coalescence", 5, def {
    v = nil
    return v ?? 5
})
test("nil coalescence assign", 5, def {
    v = nil
    v ??= 5
    return v
})
test("nil coalescence assign again", 5, def {
    v = 5
    v ??= 6
    return v
})
test("while", "5again43again2", def {
    i = 5
    s = ""
    while i > 1 {
        s += "" + i
        if i == 4 {
            i -= 1
            continue
        } else if i == 2 {
            break
        }
        s += "again"
        i -= 1
    }
    return s
})
test("do-while", "123", def {
    i = 1
    s = ""
    do {
        s += "\(i)"
        i += 1
    } while i < 4
    return s
})
test("do-while one too many", "4", def {
    i = 4
    s = ""
    do {
        s += "\(i)"
        i += 1
    } while i < 4
    return s
})
test("when", "3 or 4", def {
    i = 3
    when i {
        2 { return "2" }
        3 or 4 { return "3 or 4" }
        else { return "else " + i }
    }
})
test("if expr", 2, if 0 {
    5
} else if 0 {
    6
} else {
    2
})
test("when expr", 5, when b {
  2 = 2
  4 = 5
  else = 6
})
def funcWithOptionals(what = "func", smth = 6) {
    return what + smth
}
test("func with 2 params", "aa", funcWithOptionals("a", "a"))
test("func with 1 optional", "a6", funcWithOptionals("a"))
test("func with 2 optionals", "func6", funcWithOptionals())

def retFunc() {
    return 5
    print "this shouldn't be printed"
}
test("func with return", 5, retFunc())

def outer() {
  x = "outside"
  def inner() {
    return x
  }
  return inner
}
test("closure", "outside", def {
    closure = outer()
    return closure()
})

def selfReturning() {
    return self(def)
}
test("self(def)", selfReturning, selfReturning)

class Brioche {
    def eat(a, b) {
        return "ate \(a) and \(b)"
    }
}
test("class instantiation and invoke", "ate jam and jelly", Brioche().eat("jam", "jelly"))
test("is", true, Brioche() is Brioche)
test("is not", false, Brioche() is not Brioche)
test("class is", true, Brioche is Class)

class Pair {
    init(@first = 5, @second = 6)
}
test("class init with autoset", 3, def {
    pair = Pair(1, 2)
    return pair.first + pair.second
})
test("class init with autoset one default", 7, def {
    pair = Pair(1)
    return pair.first + pair.second
})
test("class init with autoset two defaults", 11, def {
    pair = Pair()
    return pair.first + pair.second
})

class Nested {
  ichBin = "Kuhlen"
  def method() {
    def function() {
      return @ichBin
    }
    return function()
  }
}
test("nested self access", "Kuhlen", Nested().method())

class Superclass {
    def methodToInherit() {
        return "superclass method"
    }
}
class Subclass is Superclass {
    superClassStr = "my superclass is " + super

    def methodToInherit() {
        return super.methodToInherit() + " overridden"
    }
}
test("super access", "my superclass is Superclass", Subclass().superClassStr)
test("method overriding with super invoke", "superclass method overridden", Subclass().methodToInherit())
test("is with superclass", true, Subclass() is Superclass)
test("class is with superclass", true, Subclass is Superclass)

test("Range operator", true, 1..3 is Range)
test("in", true, 2 in 1..4)
test("not in", true, 2 not in 3..4)
test("rangeUntil", true, 4 not in 1..4)
test("rangeTo", true, 4 in 1...4)
test("for loop", "1 2 3 4 5 ", def {
    s = ""
    for i in 1...5 {
        s += "\(i) "
    }
    return s
})

test("lambda with two implicit params", 3, def {
    return _0 + _1
}(1, 2))
test("shorthand lambda with three implicit params", 3, (=_0+_1+_2)(1, 1, 1))

test("native init", true, Date() != nil)
test("static native function", 1, Date.at(1).time)
test("static native function default arg", 0, Date.at(0).time)

def funcForBoxing
test("function boxing", "funcForBoxing0", funcForBoxing.name + funcForBoxing.arity)
test("function is", true, funcForBoxing is Function)

class SomeException is Exception
someExceptionMessage = "Some exception"
def funcReturningException = SomeException(someExceptionMessage)
test("returning exception", someExceptionMessage, funcReturningException().message)
test("rescue alternative value", "alternative", =funcReturningException() ?! { return "alternative"} )
def rescueFunctionWithValueAssign {
    value = funcReturningException() ?! {
        s = "exception \(it.message)"
        return s
    }
    print "nothing happened"
    return 1
}
test("rescue function with value assign", "exception \(someExceptionMessage)", rescueFunctionWithValueAssign())
def rescueFunctionWithoutValueAssign {
    funcReturningException() ?! {
        s = "exception \(it.message)"
        return s
    }
    print "nothing happened"
    return 1
}
test("rescue function with value assign", "exception \(someExceptionMessage)", rescueFunctionWithoutValueAssign())

def funcWithArgTypeCheck(a0 is String, a1 is String?, a2 is String!) {
    return 1
}
test("arg type check proper type passed", 1, funcWithArgTypeCheck("", "", ""))
test("arg type check first nil", "tme", funcWithArgTypeCheck(nil, "", "").message) # TODO rework the checks
test("arg type check first Exception", "tme", funcWithArgTypeCheck(Exception("a"), "", "").message)
test("arg type check second nil", "tme", funcWithArgTypeCheck("", nil, "").message)
test("arg type check second Exception", "tme", funcWithArgTypeCheck("", Exception("a"), "").message)
test("arg type check third nil", "tme", funcWithArgTypeCheck("", "", nil).message)
test("arg type check third Exception", 1, funcWithArgTypeCheck("", "", Exception("a")))

def funcWithReturnTypeCheckCorrect is String {
    return ""
}
test("return type check proper type", "", funcWithReturnTypeCheckCorrect())
def funcWithReturnTypeCheckIncorrect is String {
    return 1
}
test("return type check incorrect type", "tme", funcWithReturnTypeCheckIncorrect().message)

def basicDoBlockTest {
    s = ""
    do {
        s += "in do block"
        s += " yup yup"
    }
    return s
}
test("basic do block", "in do block yup yup", basicDoBlockTest())
def basicDoElseBlockTest {
    s = ""
    do {
        s += "another do"
    } else {
        s += "nope"
    }
    return s
}
test("basic do block", "another do", basicDoElseBlockTest())

def doElseBreakIt {
    s = ""
    do {
        ab = 2
        q = funcReturningException() ?! {
            c = 6
            s += it
            s += c
            break it
        }
        s += "nope"
    } else {
        c = 6
        s += c
        s += "exception \(it)"
        s += c
    }
    return s
}
test("do else break it", "SomeException instance66exception SomeException instance6", doElseBreakIt())

def doElseBreakNil {
    s = ""
    do {
        s += "3rd do"
        break
        s += "nope"
    } else {
        c = 6
        s += "yup, nil == " + it
        s += c
        s += it
    }
    return s
}
test("do else break nil", "3rd doyup, nil == nil6nil", doElseBreakNil())

def testImplicitSelf {
    class SelfTesting {
        q = 5
        def r = 3
        def _p = 2
        def w {
            s = "" + q
            q = 6
            s += q
            s += _p()
            c = r()
            s += c
            return s
        }
    }
    return SelfTesting().w()
}
test("implicit self", "5623", testImplicitSelf())

obj = [a = 1, b = 3, c = 5]
print obj
lst = $[1, 2, 3, 4, 5]
print lst
lst.2 = 10
print lst
obj.a = 3

#
#class OverridesGet {
#    def get(val) {
#        when val {
#            is Num { print "is num" }
#            is String {
#                print "is str"
#                print "super get " + super.get(val)
#             }
#            else { print "something else \(val)" }
#        }
#        return 1
#    }
#    def set(key, val) {
#        super.set(key, val)
#        print "set \(key) \(val)"
#    }
#}
#overridesGet = OverridesGet()
#print "3 == " + (overridesGet.(OverridesGet) + overridesGet.1 + overridesGet.("ssss") + overridesGet.abc)
#overridesGet.key = 42
#overridesGet.key
#

