# Comment
#* multiline comments
span
multiple lines *#

import native "Date"

class Object {

}

class Function

class Class

class Exception {
    init(@message)
}

class Range {
    init(@min, @max)

    def iterate() = Range.Iterator(self)

    def has(o) = o >= @min and o <= @max

    class Iterator {
        init(@range) {
            self.current = range.min
        }

        def next() = if @current <= @range.max {
                @current = @current + 1
                @current - 1
            } else {
                nil
            }
    }
}

class Num {
    def rangeTo(lim) = Range(@_, lim)

    def rangeUntil(lim) = Range(@_, lim - 1)

    def equals(o) = (o is Num and @_ == o._)

    def matches(o) = if self == o {
        @_
    } else {
        nil
    }
}

class String

class Date {
    native init
    native at(time = 0)
}

def test(title, expected, proc) {
    r = proc()
    print "Testing \(title): " + if r == expected "SUCCESS" else "FAIL got \(r) expected \(expected)"
}

a = 5
b = a + 3
a $= b - 4 / (2 + 2 * 2)
b /= 2
test("a is", 7.333333333333333, a)
test("b is", 4, b)
test("if", "a", =if a < 2 or a < 10 {
    "a"
} else if b == 4 {
    "b"
} else {
    "both are false"
})
test("nil coalescence", 5, def {
    v = nil
    return v ?? 5
})
test("nil coalescence assign", 5, def {
    v = nil
    v ??= 5
    return v
})
test("nil coalescence assign again", 5, def {
    v = 5
    v ??= 6
    return v
})
test("while", "5again43again2", def {
    i = 5
    s = ""
    while i > 1 {
        s += "" + i
        if i == 4 {
            i -= 1
            continue
        } else if i == 2 {
            break
        }
        s += "again"
        i -= 1
    }
    return s
})
test("do-while", "123", def {
    i = 1
    s = ""
    do {
        s += "\(i)"
        i += 1
    } while i < 4
    return s
})
test("do-while one too many", "4", def {
    i = 4
    s = ""
    do {
        s += "\(i)"
        i += 1
    } while i < 4
    return s
})
test("when", "3 or 4", def {
    i = 3
    when i {
        2 { return "2" }
        3 or 4 { return "3 or 4" }
        else { return "else" }
    }
})
test("if expr", 2, if 0 {
    5
} else if 0 {
    6
} else {
    2
})
test("when expr", 5, when b {
  2 = 2
  4 = 5
  else = 6
})
def funcWithOptionals(what = "func", smth = 6) {
    return what + smth
}
test("func with 2 params", "aa", funcWithOptionals("a", "a"))
test("func with 1 optional", "a6", funcWithOptionals("a"))
test("func with 2 optionals", "func6", funcWithOptionals())

def retFunc() {
    return 5
    print "this shouldn't be printed"
}
test("func with return", 5, retFunc())

def outer() {
  x = "outside"
  def inner() {
    return x
  }
  return inner
}
test("closure", "outside", def {
    closure = outer()
    return closure()
})

def selfReturning() {
    return self(def)
}
test("self(def)", selfReturning, selfReturning)

class Brioche {
    def eat(a, b) {
        return "ate \(a) and \(b)"
    }
}
test("class instantiation and invoke", "ate jam and jelly", Brioche().eat("jam", "jelly"))
test("is", true, Brioche() is Brioche)
test("is not", false, Brioche() is not Brioche)
test("class is", true, Brioche is Class)

class Pair {
    init(@first = 5, @second = 6)
}
test("class init with autoset", 3, def {
    pair = Pair(1, 2)
    return pair.first + pair.second
})
test("class init with autoset one default", 7, def {
    pair = Pair(1)
    return pair.first + pair.second
})
test("class init with autoset two defaults", 11, def {
    pair = Pair()
    return pair.first + pair.second
})

class Nested {
  ichBin = "Kuhlen"
  def method() {
    def function() {
      return @ichBin
    }
    return function()
  }
}
test("nested self access", "Kuhlen", Nested().method())

class Superclass {
    def methodToInherit() {
        return "superclass method"
    }
}
class Subclass is Superclass {
    superClassStr = "my superclass is " + super

    def methodToInherit() {
        return super.methodToInherit() + " overridden"
    }
}
test("super access", "my superclass is Superclass", Subclass().superClassStr)
test("method overriding with super invoke", "superclass method overridden", Subclass().methodToInherit())
test("is with superclass", true, Subclass() is Superclass)
test("class is with superclass", true, Subclass is Superclass)

test("Range operator", true, 1..3 is Range)
test("in", true, 2 in 1..4)
test("not in", true, 2 not in 3..4)
test("rangeUntil", true, 4 not in 1..4)
test("rangeTo", true, 4 in 1...4)
test("for loop", "1 2 3 4 5 ", def {
    s = ""
    for i in 1...5 {
        s += "\(i) "
    }
    return s
})

test("lambda with two implicit params", 3, def {
    return _0 + _1
}(1, 2))
test("shorthand lambda with three implicit params", 3, (=_0+_1+_2)(1, 1, 1))

test("native init", true, Date() != nil)
test("static native function", 1, Date.at(1).time)
test("static native function default arg", 0, Date.at(0).time)

def funcForBoxing
test("function boxing", "funcForBoxing0", funcForBoxing.name + funcForBoxing.arity)
test("function is", true, funcForBoxing is Function)

class SomeException is Exception
someExceptionMessage = "Some exception"
def funcReturningException = SomeException(someExceptionMessage)
test("returning exception", someExceptionMessage, funcReturningException().message)
test("rescue alternative value", "alternative", funcReturningException() ?! "alternative")
def rescueFunctionWithValueAssign {
    value = funcReturningException() ?! {
        s = "exception \(it.message)"
        return s
        nil
    }
    print "nothing happened"
    return 1
}
test("rescue function with value assign", "exception \(someExceptionMessage)", rescueFunctionWithValueAssign())
def rescueFunctionWithoutValueAssign {
    funcReturningException() ?! {
        s = "exception \(it.message)"
        return s
        nil
    }
    print "nothing happened"
    return 1
}
test("rescue function with value assign", "exception \(someExceptionMessage)", rescueFunctionWithoutValueAssign())


#CONST_ANT = 1
##CONST_ANT $= 2 # Uncomment to test assignment to const
#
#class OverridesGet {
#    def get(val) {
#        when val {
#            is Num { print "is num" }
#            is String {
#                print "is str"
#                print "super get " + super.get(val)
#             }
#            else { print "something else \(val)" }
#        }
#        return 1
#    }
#    def set(key, val) {
#        super.set(key, val)
#        print "set \(key) \(val)"
#    }
#}
#overridesGet = OverridesGet()
#print "3 == " + (overridesGet.(OverridesGet) + overridesGet.1 + overridesGet.("ssss") + overridesGet.abc)
#overridesGet.key = 42
#overridesGet.key
#

