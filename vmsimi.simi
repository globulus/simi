# Comment
#* multiline comments
span
multiple lines *#

import native "Date"

class Object {

}

class_ Function

class_ Class

class Exception {
    init(@message)
}
class TypeMismatchException is Exception {
    init {
        super.init("tme")
    }
}
class NilReferenceException is Exception
class IllegalArgumentException is Exception

class Range {
    init(@min, @max)

    def iterate() = Range.Iterator(self)

    def has(o) = o >= @min and o <= @max

    class Iterator {
        init(@range) {
            self.current = range.min
        }

        def next() = if @current <= @range.max {
                @current = @current + 1
                @current - 1
            } else {
                nil
            }
    }
}

class_ Num {

    def rangeTo(lim) = Range(@_, lim)

    def rangeUntil(lim) = Range(@_, lim - 1)

    def equals(o) = (o is Num and @_ == o._)

    def matches(o) = if self == o {
        @_
    } else {
        nil
    }

    def iterate = rangeTo(self).iterate()
}

class_ String

class_ List {
    native init
    native get(key)
    native set(key, value)
    native add(value)
    native iterate
}

class Date {
    native init
    native at(time = 0)
}

SUCCESS = "SUCCESS"
testResults = $[total = 0, failureCount = 0, failures = List()]
def test(title, expected, proc) {
    r = proc()
    testResult = if r == expected SUCCESS else "FAIL got \(r) expected \(expected)"
    msg = "Testing \(title): " + testResult
    testResults.total = testResults.total + 1
    if testResult != SUCCESS {
        testResults.failureCount = testResults.failureCount + 1
        testResults.failures.add(msg)
    }
}

a = 5
b = a + 3
a $= b - 4 / (2 + 2 * 2)
b /= 2
test("a is", 7.333333333333333, a)
test("b is", 4, b)
test("if", "a", =if a < 2 or a < 10 {
    "a"
} else if b == 4 {
    "b"
} else {
    "both are false"
})
test("nil coalescence", 5, def {
    v = nil
    return v ?? 5
})
test("nil coalescence assign", 5, def {
    v = nil
    v ??= 5
    return v
})
test("nil coalescence assign again", 5, def {
    v = 5
    v ??= 6
    return v
})
test("while", "5again43again2", def {
    i = 5
    s = ""
    while i > 1 {
        s += "" + i
        if i == 4 {
            i -= 1
            continue
        } else if i == 2 {
            break
        }
        s += "again"
        i -= 1
    }
    return s
})
test("do-while", "123", def {
    i = 1
    s = ""
    do {
        s += "\(i)"
        i += 1
    } while i < 4
    return s
})
test("do-while one too many", "4", def {
    i = 4
    s = ""
    do {
        s += "\(i)"
        i += 1
    } while i < 4
    return s
})
test("when", "3 or 4", def {
    i = 3
    when i {
        2 { return "2" }
        3 or 4 { return "3 or 4" }
        else { return "else " + i }
    }
})
test("if expr", 2, if false {
    5
} else if false {
    6
} else {
    2
})
test("when expr", 5, when b {
  2 = 2
  4 = 5
  else = 6
})
def funcWithOptionals(what = "func", smth = 6) {
    return what + smth
}
test("func with 2 params", "aa", funcWithOptionals("a", "a"))
test("func with 1 optional", "a6", funcWithOptionals("a"))
test("func with 2 optionals", "func6", funcWithOptionals())

def retFunc() {
    return 5
    print "this shouldn't be printed"
}
test("func with return", 5, retFunc())

def outer() {
  x = "outside"
  def inner() {
    return x
  }
  return inner
}
test("closure", "outside", def {
    closure = outer()
    return closure()
})

def selfReturning() {
    return self(def)
}
test("self(def)", selfReturning, selfReturning)

class Brioche {
    def eat(a, b) {
        return "ate \(a) and \(b)"
    }
}
test("class instantiation and invoke", "ate jam and jelly", Brioche().eat("jam", "jelly"))
test("is", true, Brioche() is Brioche)
test("is not", false, Brioche() is not Brioche)
test("class is", true, Brioche is Class)

class Pair {
    init(@first = 5, @second = 6)
}
test("class init with autoset", 3, def {
    pair = Pair(1, 2)
    return pair.first + pair.second
})
test("class init with autoset one default", 7, def {
    pair = Pair(1)
    return pair.first + pair.second
})
test("class init with autoset two defaults", 11, def {
    pair = Pair()
    return pair.first + pair.second
})

class Nested {
  ichBin = "Kuhlen"
  def method() {
    def function() {
      return @ichBin
    }
    return function()
  }
}
test("nested self access", "Kuhlen", Nested().method())

class Superclass {
    def methodToInherit() {
        return "superclass method"
    }
}
class Subclass is Superclass {
    superClassStr = "my superclass is " + super

    def methodToInherit() {
        return super.methodToInherit() + " overridden"
    }
}
test("super access", "my superclass is Superclass", Subclass().superClassStr)
test("method overriding with super invoke", "superclass method overridden", Subclass().methodToInherit())
test("is with superclass", true, Subclass() is Superclass)
test("class is with superclass", true, Subclass is Superclass)

test("Range operator", true, 1..3 is Range)
test("in", true, 2 in 1..4)
test("not in", true, 2 not in 3..4)
test("rangeUntil", true, 4 not in 1..4)
test("rangeTo", true, 4 in 1...4)
test("for loop", "1 2 3 4 5 ", def {
    s = ""
    for i in 1...5 {
        s += "\(i) "
    }
    return s
})
test("for loop with obj decomp", "1a2b3c", def {
    s = ""
    for [k, v] in [[1, "a"], [2, "b"], [3, "c"]] {
        s += k + v
    }
    return s
})
test("for else with else triggering", "for else", def {
    for g in nil {
        return "nope"
    } else {
        return "for else"
    }
})
test("for else with else not triggering", "yep", def {
    for g in 1 {
        return "yep"
    } else {
        return "for else"
    }
})

test("lambda with two implicit params", 3, def {
    return _0 + _1
}(1, 2))
test("shorthand lambda with three implicit params", 3, (=_0+_1+_2)(1, 1, 1))

test("native init", true, Date() != nil)
test("static native function", 1, Date.at(1).time)
test("static native function default arg", 0, Date.at(0).time)

def funcForBoxing
test("function boxing", "funcForBoxing0", funcForBoxing.name + funcForBoxing.arity)
test("function is", true, funcForBoxing is Function)

class SomeException is Exception
someExceptionMessage = "Some exception"
def funcReturningException = SomeException(someExceptionMessage)
test("returning exception", someExceptionMessage, funcReturningException().message)
test("rescue alternative value", "alternative", =funcReturningException() ?! { return "alternative"} )
def rescueFunctionWithValueAssign {
    value = funcReturningException() ?! {
        s = "exception \(it.message)"
        return s
    }
    print "nothing happened"
    return 1
}
test("rescue function with value assign", "exception \(someExceptionMessage)", rescueFunctionWithValueAssign())
def rescueFunctionWithoutValueAssign {
    funcReturningException() ?! {
        s = "exception \(it.message)"
        return s
    }
    print "nothing happened"
    return 1
}
test("rescue function with value assign", "exception \(someExceptionMessage)", rescueFunctionWithoutValueAssign())
def funcReturningExceptionIfTrue(arg) = if arg funcReturningException() else 1
def rescueFunctionWithTwoExceptions() {
    s = ""
    s += funcReturningExceptionIfTrue(false) + funcReturningExceptionIfTrue(false) ?! {
        s += "error"
    }
    s += funcReturningExceptionIfTrue(true) + funcReturningExceptionIfTrue(false) ?! {
        s += "error"
    }
    s += funcReturningExceptionIfTrue(false) + funcReturningExceptionIfTrue(true) ?! {
        s += "error"
    }
    s += funcReturningExceptionIfTrue(true) + funcReturningExceptionIfTrue(true) ?! {
        s += "error"
    }
    return s
}
test("rescue function with multiple exception calls", "2errorerrorerror", rescueFunctionWithTwoExceptions())

def funcWithArgTypeCheck(a0 is String, a1 is String?, a2 is String!) {
    return 1
}
test("arg type check proper type passed", 1, funcWithArgTypeCheck("", "", ""))
test("arg type check first nil", "tme", funcWithArgTypeCheck(nil, "", "").message) # TODO rework the checks
test("arg type check first Exception", "tme", funcWithArgTypeCheck(Exception("a"), "", "").message)
test("arg type check second nil", "tme", funcWithArgTypeCheck("", nil, "").message)
test("arg type check second Exception", "tme", funcWithArgTypeCheck("", Exception("a"), "").message)
test("arg type check third nil", "tme", funcWithArgTypeCheck("", "", nil).message)
test("arg type check third Exception", 1, funcWithArgTypeCheck("", "", Exception("a")))

def funcWithReturnTypeCheckCorrect is String {
    return ""
}
test("return type check proper type", "", funcWithReturnTypeCheckCorrect())
def funcWithReturnTypeCheckIncorrect is String {
    return 1
}
test("return type check incorrect type", "tme", funcWithReturnTypeCheckIncorrect().message)

def basicDoBlockTest {
    s = ""
    do {
        s += "in do block"
        s += " yup yup"
    }
    return s
}
test("basic do block", "in do block yup yup", basicDoBlockTest())
def basicDoElseBlockTest {
    s = ""
    do {
        s += "another do"
    } else {
        s += "nope"
    }
    return s
}
test("basic do block", "another do", basicDoElseBlockTest())

def doElseBreakIt {
    s = ""
    do {
        ab = 2
        q = funcReturningException() ?! {
            c = 6
            s += it
            s += c
            break it
        }
        s += "nope"
    } else {
        c = 6
        s += c
        s += "exception \(it)"
        s += c
    }
    return s
}
test("do else break it", "SomeException instance66exception SomeException instance6", doElseBreakIt())

def doElseBreakNil {
    s = ""
    do {
        s += "3rd do"
        break
        s += "nope"
    } else {
        c = 6
        s += "yup, nil == " + it
        s += c
        s += it
    }
    return s
}
test("do else break nil", "3rd doyup, nil == nil6nil", doElseBreakNil())

def testImplicitSelf {
    class SelfTesting {
        q = 5
        def r = 3
        def _p = 2
        def w {
            s = "" + q
            q = 6
            s += q
            s += _p()
            c = r()
            s += c
            return s
        }
    }
    return SelfTesting().w()
}
test("implicit self", "5623", testImplicitSelf())

test("obj literal", 5, =[a = 1, b = 3, c = 5].c)
test("mut list literal", "$[1, 2, 3, 4, 5]", ="" + $[1, 2, 3, 4, 5])
test("mut list value change", 10, def {
    lst = $[1, 2, 3, 4, 5]
    lst.2 = 10
    return lst.2
})
test("list for iteration", "123", def {
    s = ""
    for i in [1, 2, 3] {
        s += i
    }
    return s
})
test("obj decomp", "nilnil5", def {
    obj = [a = 1, b = 3, c = 5]
    [d, e, c] = obj
    s = "" + d
    s += e
    s += c
    return s
})

test("custom toString", "10", def {
    class ToString {
        init(@val)
        def toString = "\(@val)"
    }
    return "" + ToString(10)
})

test("annotations", "[AnnotatedClass = [[a = class annot], Annotation constructor annot], field = [Annotation field annot], a = [[a = fun annot]], b = [[a = 2nd fun annot]]]", def {
    class AnnotationClass {
        init(@msg)

        def toString = "Annotation \(@msg)"
    }

    ![a = "class annot"]
    !AnnotationClass("constructor annot")
    class AnnotatedClass {
        !AnnotationClass("field annot")
        field = 5

        ![a = "fun annot"]
        def a() {
            print "55"
        }

        ![a = "2nd fun annot"]
        def b() {
            print "66"
        }
    }
    return "" + AnnotatedClass!
})

test("gu", 6, gu "2 + 2 * 2")
test("gu with lexer exception", "lex", def {
    return gu "2 ++ 2" ?! { return "lex" }
})
test("gu with compile exception", "comp", def {
    return gu "for 2 in 3" ?! { return "comp" }
})

test("fiber yield from foreach", "121232453564785906", def {
    def foreach(it, fun) {
        for i in it {
            fun(i)
        }
    }

    fib Fiber(p1, p2) {
        foreach(1..10, def (i){
            yield "" + p1 + p2 + i
        })
    }

    s = ""
    fajber = Fiber()
    s += fajber(1, 2)
    s += fajber(2, 3)
    s += fajber(4, 5)
    s += fajber(5, 6)
    s += fajber(7, 8)
    s += fajber(9, 0)
    return s
})
def foreach(it, fun) {
    for i in it {
        fun(i)
    }
}
test("two fibers", 8, def {
    fib F1(p) {
        foreach(p..5, def (i){
            yield i
        })
    }

    fib F2(p) {
        sum = 0
        f1 = F1()
        while sum < 5 {
            sum += p
            sum += f1(1)
            yield sum
        }
    }

    f2 = F2()
    res = f2(1)
    res += f2(2)
    return res
})

test("onsite import", "6 innerA innerB 3 3", def {
    module ModuleClass {
        field = 2 + 2 * 2

        class InnerA {
            def toString = "innerA"
        }
        class InnerB {
            def toString = "innerB"
        }
        module InnerModule {
            class InnerModuleClass
            def InnerModuleDef = 3
        }
    }
    def moduleTest {
        import ModuleClass for field, InnerA, InnerB, InnerModule
        return field + " " + InnerA() + " " + InnerB() + " " + InnerModule.InnerModuleDef() + " " + ModuleClass.InnerModule.InnerModuleDef()
    }
    return moduleTest()
})

test("proc do", 5, def {
    i = 10
    p = do {
        if i < 20 {
            break 20
        }
        5
    }
    i $= p() + 5
    j = p()
    return j
})
test("proc do else", 20, def {
    i = 10
    p = do {
        if i < 20 {
            break 20
        }
        5
    } else {
        25
    }
    i $= p() + 5
    j = p()
    return j
})

print "Testing complete, failed \(testResults.failureCount) / \(testResults.total)"
for failure in testResults.failures {
    print failure
}

fib MyFiber(a, b, c) {
    foreach(a..b, def (i) {
        yield i + c
    })
}
myFiber = MyFiber()
print myFiber(0, 3, 1)
print myFiber(5, 3, 5)
print myFiber(6, 3, 10)
print myFiber(8, 3, 20)
print myFiber(5, 10, 0)
