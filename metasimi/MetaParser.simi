
class ParseException(Exception)=
end

class Pass=
end

class Stmt=
    def accept(visitor) = pass
end

class BlockStmt=
    def children() = pass
end

class StmtBreak(Stmt)=
    def init(name) = pass
    def accept(visitor) = visitor.visitBreakStmt(self)
end

class StmtClass(Stmt)=
    def init(name, superclasses, constants, methods, doc) = pass
    def accept(visitor) = visitor.visitClassStmt(self)
end

class StmtContinue(Stmt)=
    def init(name) = pass
    def accept(visitor) = visitor.visitContinueStmt(self)
end

class StmtExpr(Stmt)=
    def init(expression) = pass
    def accept(visitor) = visitor.visitExpressionStmt(self)
end

class StmtFunction(Stmt)=
    def init(name, block, doc) = pass
    def accept(visitor) = visitor.visitFunctionStmt(self)
end

class StmtElsif(Stmt, BlockStmt)=
    def init(condition, thenBranch) = pass
    def accept(visitor) = visitor.visitElsifStmt(self)
    def children() = return @thenBranch.statements.where(def s = s is BlockStmt)
end

class StmtIf(Stmt, BlockStmt)=
    def init(ifstmt, elsifs, elseBranch) = pass
    def accept(visitor) = visitor.visitIfStmt(self)
    def children()=
        children = $[@ifstmt]
        children.addAll(@elsifs)
        if @elseBranch = children.addAll(@elseBranch.statements.where(def s = s is BlockStmt))
        return children
    end
end

class StmtPrint(Stmt)=
    def init(expression) = pass
    def accept(visitor) = visitor.visitPrintStmt(self)
end

class StmtRescue(Stmt)=
    def init(keyword, block) = pass
    def accept(visitor) = visitor.visitRescueStmt(self)
end

class StmtReturn(Stmt)=
    def init(keyword, value) = pass
    def accept(visitor) = visitor.visitReturnStmt(self)
end

class StmtWhile(Stmt, BlockStmt)=
    def init(condition, block) = pass
    def accept(visitor) = visitor.visitWhileStmt(self)
    def children() = return @body.statements.where(def s = s is BlockStmt)
end

class StmtFor(Stmt, BlockStmt)=
    def init(var, iterable, body) = pass
    def accept(visitor) = visitor.visitForStmt(self)
    def children() = return @body.statements.where(def s = s is BlockStmt)
end

class StmtYield(Stmt)=
    def init(keyword, value) = pass
    def accept(visitor) = visitor.visitYieldStmt(self)
end

class StmtYield(Stmt)=
    def init(keyword, value) = pass
    def accept(visitor) = visitor.visitYieldStmt(self)
end

class Expr=
    def accept(visitor, params) = pass
end

class ExprBlock(Expr)=
    def init(declaration, params, statements) = pass

    def accept(visitor, params)=
        newSCope = ife(params.isEmpty(), true, params.0)
        return visitor.visitBlockExp(self, newScope)
    end

    def isNative() = return declaration.type == TokenType.NATIVE

    def getStatements() = return statements

    def yieldBlock(index) = print("Trying to yield an ExprBlock!")

    def isEmpty()=
        if @statements.length() != 1 = return false
        stmt = @statements.0
        if stmt is not StmtExpr = return false
        if stmt.expression is not ExprLiteral = return false
        return stmt.expression.value is Pass
    end
end

class ExprAssign(Expr)=
    def init(name, value) = pass
    def accept(visitor, params) = visitor.visitAssignExpr(self)
end

class ExprBinary(Expr)=
    def init(left, op, right) = pass
    def accept(visitor, params) = visitor.visitBinaryExpr(self)
end

class ExprCall(Expr)=
    def init(callee, paren, args) = pass
    def accept(visitor, params) = visitor.visitCallExpr(self)
end

class ExprGet(Expr)=
    def init(origin, object, name, arity) = pass
    def accept(visitor, params) = visitor.visitGetExpr(self)
end

class ExprGrouping(Expr)=
    def init(expression) = pass
    def accept(visitor, params) = visitor.visitGroupingExpr(self)
end

class ExprGu(Expr)=
    def init(string) = pass
    def accept(visitor, params) = visitor.visitGuExpr(self)
end

class ExprLiteral(Expr)=
    def init(value) = pass
    def accept(visitor, params) = visitor.visitLiteralExpr(self)
end

class ExprLogical(Expr)=
    def init(left, op, right) = pass
    def accept(visitor, params) = visitor.visitLogicalExpr(self)
end

class ExprSet(Expr)=
    def init(origin, object, name, value) = pass
    def accept(visitor, params) = visitor.visitSetExpr(self)
end

class ExprSuper(Expr)=
    def init(keyword, superclass, method, arity) = pass
    def accept(visitor, params) = visitor.visitSuperExpr(self)
end

class ExprSelf(Expr)=
    def init(keyword) = pass
    def accept(visitor, params) = visitor.visitSelfExpr(self)
end

class ExprUnary(Expr)=
    def init(op, right) = pass
    def accept(visitor, params) = visitor.visitUnaryExpr(self)
end

class ExprVar(Expr)=
    def init(name) = pass
    def accept(visitor, params) = visitor.visitVarExpr(self)
end

class ExprObjectLiteral(Expr)=
    def init(opener, props, isDictionary) = pass
    def accept(visitor, params) = visitor.visitObjectLiteralExpr(self)
end

class Parser=
    def init(tokens) = pass

    def parse()=
        @current = 0
        stmts = $$[]
        while not @_isAtEnd()=
            if @_match(TokenType.IMPORT)=
                @_advance()
                continue
            end
            if @_match([TokenType.NEWLINE, TokenType.PASS]) = continue
            if @_match(TokenType.STRING)=
                @doc = @_previous().literal
                continue
            end
            stmts.append(@_declaration())
        end
        return stmts
    end

    def _expression() = return @_assignment()

    def _declaration()=
        if @_match(TokenType.CLASS) = return @_classDeclaration()
        if @_match([TokenType.DEF, TokenType.NATIVE]) = return @_function("function")
        return @_statement(false)
        rescue parseEx=
            if parseEx=
                @_synchronize()
                return nil
            end
        end
    end

    def _classDeclaration()=
        doc = @doc
        @doc = nil
        name = @_consume(TokenType.IDENTIFIER, "Expected class name.")
        $superclasses = nil
        if @_check(TokenType.LEFT_PAREN)=
            $superclasses = @_params("class", false).map(def p = ExprVar(p))
        end
        @_consume(TokenType.COLON, "Expected '=' before class body.")
        constants = $$[]
        methods = $$[]
        while not @_check(TokenType.END) and not @_isAtEnd()=
            if @_match(TokenType.NEWLINE) = continue
            if @_match(TokenType.STRING)=
                @doc = @_previous().lexeme
                continue
            end
            if @_match([TokenType.DEF, TokenType.NATIVE]) = methods.append(@_function("method"))
            else = constants.append(@_assignment())
        end
        @_consume(TokenType.END, "Expect 'end' after class body.")
        return StmtClass(name, superclasses, constants, methods, doc)
    end

    def _statement(lambda)=
        if @_match(TokenType.FOR) = return @_forStatement()
        if @_match(TokenType.IF) = return @_ifStatement()
        if @_match(TokenType.PRINT) = return @_printStatement(lambda)
        if @_match(TokenType.RETURN) = return @_returnStatement(lambda)
        if @_match(TokenType.YIELD) = return @_yieldStatement(lambda)
        if @_match(TokenType.WHILE) = return @_whileStatement()
        if @_match(TokenType.BREAK) = return @_breakStatement()
        if @_match(TokenType.CONTINUE) = return @_continueStatement()
        if @_match(TokenType.RESCUE) = return @_rescueStatement()
        return @_expressionStatement(lambda)
    end

    def _forStatement()=
#        print "for declr"
        var = @_consume(TokenType.IDENTIFIER, "Expected identifier.")
        @_consume(TokenType.IN, "Expected 'in'.")
        iterable = @_expression()
        body = @_block("for", true)
        return StmtFor(ExprVar(var), iterable, body)
    end

    def _ifStatement()=
#        print "if declr"
        condition = @_expression()
        thenBranch = @_block("if", true)
        $elseBranch = nil
        elsifs = $$[]
        while @_match([TokenType.ELSIF, NEWLINE])=
            if @_previous().type == TokenType.ELSIF = elsifs.append(StmtElsif(@_expression(), @_block("elsif", true)))
        end
        if @_match(TokenType.ELSE) = $elseBranch = @_block("else", true)
        return StmtIf(StmtElsif(condition, thenBranch), elsifs, elseBranch)
    end

    def _printStatement(lambda) = return StmtPrint(@_expressionStatement(lambda).expression)

    def _returnStatement(lambda)=
#        print "return declr"
        keyword = @_previous()
        $value = nil
        if not @_check(TokenType.NEWLINE) = $value = @_expression()
        @_checkStatementEnd(lambda)
        return StmtReturn(keyword, $value)
    end

    def _yieldStatement(lambda)=
#        print "yield declr"
        keyword = @_previous()
        $value = nil
        if not @_check(TokenType.NEWLINE) = $value = @_expression()
        @_checkStatementEnd(lambda)
        return StmtYield(keyword, $value)
    end

    def _whileStatement=
#        print "while declr"
        condition = @_expression()
        block = @_block("while", true)
        return StmtWhile(condition, block)
    end

    def _breakStatement = return StmtBreak(@_previous())

    def _continueStatement = return StmtContinue(@_previous())

    def _rescueStatement=
        keyword = @_previous()
        block = @_block("rescue", true)
        if block.params.length() != 1 = @_error(keyword, "Rescue block expects exactly 1 param!")
        return StmtRescue(keyword, block)
    end

    def _expressionStatement(lambda)=
        expr = @_expression()
        @_checkStatementEnd(lambda)
        #print "returning stmt expr " + @_peek()
        return StmtExpr(expr)
    end

    def _checkStatementEnd(lambda)=
        if @_match(TokenType.NEWLINE) or\
            lambda and @_peek().type in [TokenType.COMMA, TokenType.RIGHT_PAREN, TokenType.RIGHT_BRACKET] = return
        @_error(@_peek(), "Unterminated lambda expression!")
    end

    def _function(kind)=
        declaration = @_previous()
        doc = @doc
        @doc = nil
        name = @_consume(TokenType.IDENTIFIER, "Expect " + kind + " name.")
        blockKind = ife(name.lexeme == "init", "init", kind)
        $block = @_block(declaration, blockKind, false)

        # Check empty init and put assignments into it
        if name.lexeme == "init" and $block.isEmpty()=
            for param in block.params = statements.add(StmtExpr(ExprSet(name, ExprSelf(Token.selfToken()), ExprVar(param), ExprVar(param))))
            $block = ExprBlock(declaration, $block.params, statements)
        end
        return StmtFunction(name, $block, doc)
    end

    def _block(kind, lambda) = return @_block(nil, kind, lambda)

    def _block($declaration, kind, lambda)=
#        print "block declr " + kind
        if $declaration == nil = $declaration = @_previous()
        params = @_params(kind, lambda)
        @_consume(TokenType.COLON, "Expect a '=' at the start of block!")
        statements = $$[]
#        print "consuming block " + kind+" " +@_peek()
        if @_match(TokenType.NEWLINE)=
#            print "kind is " + kind
            while not @_check(TokenType.END) and not @_isAtEnd()=
#                print "loop iter = " + kind+" " + @current
                if @_match([TokenType.NEWLINE, TokenType.PASS]) = continue
                statements.append(@_declaration())
#                print "got decl " + kind + " " + statements.length()
#                statements.forEach(def v = print v)
            end
#            print "block declr terminated = " + kind+" "  + @_peek()
            @_consume(TokenType.END, "Expect 'end' after block.")
        end else=
            $stmt = @_statement(true)
            if kind == "lambda" and $stmt is StmtExpr = $stmt = StmtReturn($declaration, $stmt.expression)
            statements.append($stmt)
        end
#        print "consumed block " + kind
        return ExprBlock($declaration, params, statements)
    end

    def _params(kind, lambda)=
        params = $$[]
        if not @_check(TokenType.LEFT_PAREN)=
            if lambda and not @_check(TokenType.COLON) = params.append(@_consumeParam())
        end else=
            @_consume(TokenType.LEFT_PAREN, "Expect '(' after " + kind + " name.")
            if not @_check(TokenType.RIGHT_PAREN)=
                @_consumeParam()
                while @_match(TokenType.COMMA) = @_consumeParam()
            end
            @_consume(TokenType.RIGHT_PAREN, "Expect ')' after params!")
        end
        return params
    end

    def _consumeParam() = return @_consume(TokenType.IDENTIFIER, "Expected param name!")

    def _peekParams()=
        if not @_check(TokenType.LEFT_PAREN) = return nil
        if @_peekSequence([TokenType.LEFT_PAREN, TokenType.RIGHT_PAREN]) = return 0
        len = @tokens.length()
        $count = 1
        $parenCount = 0
        for i in Range(@current + 1, len)=
            type = (tokens.(i)).type
            if type == TokenType.LEFT_PAREN = $parenCount += 1
            elsif type == TokenType.RIGHT_PAREN=
                if $parenCount == 0 = break
                else = $parenCount -= 1
            end
            elsif type == TokenType.COMMA and $parenCount == 0 = $count += 1
        end
        return $count
    end

    def _assignment()=
#        print "assignment expr " + @_peek()
        expr = @_or()
        if @_match([TokenType.EQUAL, TokenType.PLUS_EQUAL, TokenType.MINUS_EQUAL,\
                TokenType.STAR_EQUAL, TokenType.SLASH_EQUAL, TokenType.MOD_EQUAL])=
            equals = @_previous()
            value = @_assignment()
            if expr.value is $String=
                literal = Token(TokenType.STRING, nil, expr.value, equals.line)
                return ExprAssign(literal, value)
            end
            if expr is ExprVar=
                name = expr.name
                if equals.type == TokenType.EQUAL = return ExprAssign(name, value)
                else = return ExprAssign(name, ExprBinary(expr, @_operatorFromAssign(equals), value))
            end
            if expr is ExprGet=
                if equals.type == TokenType.EQUAL = return ExprSet(expr.origin, expr.object, expr.name, value)
                else = @_error(equals, "Cannot use compound assignment operators with setters!")
            end
            @_error(equals, "Invalid assignment target.")
        end
        return expr
    end

    def _or()=
        $expr = @_and()
        while @_match(TokenType.OR)=
            op = @_previous()
            right = @_and()
            $expr = ExprLogical($expr, op, right)
        end
        return $expr
    end

    def _and()=
        $expr = @_equality()
        while @_match(TokenType.AND)=
            op = @_previous()
            right = @_equality()
            $expr = ExprLogical($expr, op, right)
        end
        return $expr
    end

    def _equality()=
        $expr = @_comparison()
        while @_match([TokenType.BANG_EQUAL, TokenType.EQUAL_EQUAL, TokenType.IS, TokenType.ISNOT, TokenType.IN, TokenType.NOTIN])=
            op = @_previous()
            right = @_comparison()
            $expr = ExprBinary($expr, op, right)
        end
        return $expr
    end

    def _comparison()=
        $expr = @_addition()
        while @_match([TokenType.GREATER, TokenType.GREATER_EQUAL, TokenType.LESS, TokenType.LESS_EQUAL, TokenType.LESS_GREATER])=
            op = @_previous()
            right = @_addition()
            $expr = ExprBinary($expr, op, right)
        end
        return $expr
    end

    def _addition()=
        $expr = @_multiplication()
        while @_match([TokenType.MINUS, TokenType.PLUS])=
            op = @_previous()
            right = @_multiplication()
            $expr = ExprBinary($expr, op, right)
        end
        return $expr
    end

    def _multiplication()=
        $expr = @_nilCoalescence()
        while @_match([TokenType.SLASH, TokenType.STAR, TokenType.MOD])=
            op = @_previous()
            right = @_nilCoalescence()
            $expr = ExprBinary($expr, op, right)
        end
        return $expr
    end

    def _nilCoalescence()=
        $expr = @_unary()
        while @_match(TokenType.QUESTION_QUESTION)=
            op = @_previous()
            right = @_unary()
            $expr = ExprBinary($expr, op, right)
        end
        return $expr
    end

    def _unary()=
       if @_match([TokenType.NOT, TokenType.MINUS])=
            op = @_previous()
            right = @_unary()
            return ExprUnary(op, right)
       end
       if @_match(TokenType.GU)=
        string = @_primary()
        return ExprGu(string)
       end
       return @_call()
    end

    def _call()=
        $expr = @_primary()
        while true=
            if @_match(TokenType.LEFT_PAREN) = $expr = @_finishCall($expr)
            elsif @_match(TokenType.DOT)=
                dot = @_previous()
                $name = nil
                if @_peek().type == TokenType.NUMBER = $name = ExprVar(@_consume(TokenType.NUMBER, "Expected a number or id after '.'."))
                elsif @_peek().type == TokenType.LEFT_PAREN = $name = @_or()
                else = $name = ExprVar(@_consume(TokenType.IDENTIFIER, "Expected a number or id after '.'."))
                arity = @_peekParams()
                $expr = ExprGet(dot, $expr, $name, arity)
            end
            else = break
        end
#            print "checking param expr " + @_peek()
        return $expr
    end

    def _finishCall(callee)=
#        print "finish call expr " + @_peek()
        args = $$[]
        if not @_check(TokenType.RIGHT_PAREN)=
            args.append(@_getCallParam())
            while @_match(TokenType.COMMA) = args.append(@_getCallParam())
        end
        paren = @_consume(TokenType.RIGHT_PAREN, "Expect ')' after arguments.")
        return ExprCall(callee, paren, args)
    end
    
    def _getCallParam()=
        @_matchSequence([TokenType.IDENTIFIER, TokenType.EQUAL])
        return @_expression()
    end
    
    def _primary()=
#        print "primary expr " + @_peek()
        if @_match(TokenType.FALSE) = return ExprLiteral(false)
        if @_match(TokenType.TRUE) = return ExprLiteral(true)
        if @_match(TokenType.NIL) = return ExprLiteral(nil)

        if @_match(TokenType.PASS) = return ExprLiteral(Pass())

        if @_match([TokenType.NUMBER, TokenType.STRING]) = return ExprLiteral(@_previous().literal)

        if @_match(TokenType.SUPER)=
          keyword = @_previous()
          $superclass = nil
          if @_match(TokenType.LEFT_PAREN)=
            $superclass = @_consume(TokenType.IDENTIFIER, "Expected superclass name in parentheses!")
            @_consume(TokenType.RIGHT_PAREN, "Expected ')' after superclass specification!")
          end
          @_consume(TokenType.DOT, "Expect '.' after 'super'.")
          method = @_consume(TokenType.IDENTIFIER, "Expect superclass method name.")
          arity = @_peekParams()
          return ExprSuper(keyword, $superclass, method, arity)
        end

        if @_match(TokenType.SELF) = return ExprSelf(Token(TokenType.SELF, "self", nil, @_previous().line))

        if @_match([TokenType.LEFT_BRACKET, TokenType.DOLLAR_LEFT_BRACKET]) = return @_objectLiteral()

        if @_match([TokenType.DEF, TokenType.NATIVE]) = return @_block("lambda", true)

        if @_match(TokenType.IDENTIFIER) = return ExprVar(@_previous())

        if @_match(TokenType.LEFT_PAREN)=
          expr = @_expression()
          @_consume(TokenType.RIGHT_PAREN, "Expect ')' after expression.")
          return ExprGrouping(expr)
        end

        if @_match(TokenType.QUESTION) = return ExprUnary(@_previous(), @_primary())

        @_error(@_peek(), "Expect expression.")
    end

    def _objectLiteral()=
        opener = @_previous()
        props = $$[]
        $dictionary = true
        if not @_check(TokenType.RIGHT_BRACKET)=
            @_matchAllNewlines()
            $dictionary = @_peekSequence([TokenType.IDENTIFIER, TokenType.EQUAL]) or @_peekSequence([TokenType.STRING, TokenType.EQUAL])
            props.append(@_getObjectLiteralProp($dictionary))
            while @_match(TokenType.COMMA) = props.append(@_getObjectLiteralProp($dictionary))
            @_matchAllNewlines()
        end
        @_consume(TokenType.RIGHT_BRACKET, "Expect ']' at the end of object.")
        return ExprObjectLiteral(opener, props, $dictionary)
    end

    def _getObjectLiteralProp(dictionary)=
        @_matchAllNewlines()
        if dictionary = return @_assignment()
        else = return @_or()
    end

    def _matchAllNewlines=
        while @_match(TokenType.NEWLINE) = pass
    end

    def _matchSequence(types)=
        for i in types.length().times()=
            index = @current + i
            if index >= @tokens.length() = return false
            if tokens.(index).type != types.(i) = return false
        end
        for i in types.length().times() = @_advance()
        return true
    end

    def _match(types)=
        if types is $Object=
            for type in types=
                if @_matchOne(type) = return true
            end
            return false
        end
        return @_matchOne(types)
    end

    def _matchOne(type)=
        if @_check(type)=
            @_advance()
            return true
        end
        return false
    end

    def _consume(type, message)=
        if @_check(type) = return @_advance()
        @_error(@_peek(), message)
    end

    def _check(type)=
        if @_isAtEnd() = return false
        return @_peek().type == type
    end

    def _advance()=
        if not @_isAtEnd() = @current = @current + 1
        return @_previous()
    end

    def _isAtEnd() = return @_peek().type == TokenType.EOF

    def _peek() = return @tokens.(@current)

    def _peekSequence(types)=
        if @current + types.length() >= @tokens.length() = return false
        for i in types.length().times()=
            if (@tokens.(@current + i)).type != types.(i) = return false
        end
        return true
    end

    def _previous() = return @tokens.(@current - 1)

    def _operatorFromAssign(assignOp)=
        $type = nil
        if assignOp.type == TokenType.PLUS_EQUAL = $type = TokenType.PLUS
        elsif assignOp.type == TokenType.MINUS_EQUAL = $type = TokenType.MINUS
        elsif assignOp.type == TokenType.STAR_EQUAL = $type = TokenType.STAR
        elsif assignOp.type == TokenType.SLASH_EQUAL = $type = TokenType.SLASH
        elsif assignOp.type == TokenType.MOD_EQUAL = $type = TokenType.MOD
        else = @_error(assignOp, "Unable to process assignment operator")
        return Token($type, assignOp.lexeme, nil, assignOp.line)
    end

    def _error(token, message)=
        print token + " " + message
    end

    def _synchronize()=
        @_advance()
        while not @_isAtEnd()=
            @_advance()
        end
    end

end