class Return(Exception)=
    def init(value)=
        super.init("Return")
        @value = value
    end
end

class Yield(Exception)=
    def init(value)=
        super.init("Yield")
        @value = value
    end
end

class BlockImpl=
    def init(delcaration, closure) = pass

    def bind(instance)=
        env = Environment(closure)
        env.assign(Token.selfToken(), instance, false)
        return BlockImpl(@declaration, env)
    end

    def isNative() = return @declaration.isNative()

    def yieldBlock(index)=
        @_lastStatement = index
        @_lastClosure = @closure
    end

    def _clearYield()=
        @_lastStatement = nil
        @_lastClosure = nil
    end

    def arity() = return @declaration.params.length()

    def call(interpreter, args, rethrow)=
        env = Environment(@_lastClosure ?? @closure)
        if args=
            for i in @declaration.params.length().times() = env.define(@(declaration.params.(i)).lexeme, args.(i))
        end
        interpreter.executeBlock(self, env, @_lastStatement ?? 0)
        rescue ex=
            if ex is Return=
                @_clearYield()
                if rethrow = ex.raise()
                else = return ex.value
            end
            else if ex is Yield=
                if rethrow = Yield(ex.value, true).raise()
                else = return ex.value
            end
        end
        @_clearYield()
        return nil
    end

    def statements() = return @declaration.statements()
end

class Environment=
    def init()=
        @depth = 0
        @_initFields()
    end

    def init(enclosing)=
        @enclosing = enclosing
        @depth = enclosing.depth + 1
        @_initFields()
    end

    def _initFields()=
        @values = $[]
        @statementBlocks = $[]
    end

    def get(token)=
        $val = @values.(token.lexeme)
        if $val = return $val
        if @enclosing = return @enclosing.get(token)
        return nil
    end

    def assign(token, value, allowImmutable)=
        key = token.lexeme
        if key in @values=
            if allowImmutable or key.startsWith("$") = @values.(key) = value
            else = print "Cannot assign to a const"
        end else = @define(key, value)
    end

    def define(name, value) = @values.(name) = value

    def ancestor(distance)=
        $env = self
        for i in distance.times() = $env = $env.enclosing
        return $env
    end

    def getAt(distance, name) = return @ancestor(distance).values.get(name)

    def assignAt(distance, token, value) = @ancestor(distance).assign(token, value, false)

    def tryGet(name)=
        $env = self
        while $env=
            value = $env.values.get(name)
            if value = return value
            $env = $env.enclosing
        end
        return nil
    end

    def toString()=
        sb = $String.builder()
        sb.add(values.toString())
        if @enclosing = sb.add(" -> ").add(@enclosing.toString())
        return sb.build()
    end

    def getOrAssignBlock(stmt, declaration, yieldedStmts)=
        str = stmt.toString()
        $block = @statementBlocks.(str)
        if $block=
            yieldedBlocks = yieldedStmts.(str)
            if yieldedBlocks = $block = yieldedBlocks.(@depth.toString())
            if $block=
                $block = BlockImpl(declaration, self)
                @statementBlocks.(str) = $block
            end
        end
        return $block
    end

    def endBlock(stmt, yieldedStmts)=
        str = stmt.toString()
        @statementBlocks.(str) = nil
        @popBlock(str, yieldedStmts)
        for child in stmt.children() = @endBlock(child, yieldedStmts)
    end

    def popBlock(str, yieldedStmts)=
        blocks = yieldedStmts.(str)
        if blocks = blocks.(@depth.toString()) = nil
    end
end

class Interpreter=
    def init(nativeModulesManager)=
        @nativeModulesManager = nativeModulesManager
        @_globals = Environment()
        @_environment = @_globals
#        @_locals = $[]
        @_loopBlocks = $$[]
        @_raisedExceptions = $$[]
        @_yieldedStmts = $[]
    end

    def interpret(statements)=
        for stmt in statements=
            if @_raisedExceptions.isEmpty() = @_execute(stmt)
            else = @_raisedExceptions.last().raise()
        end
    end

    def _evaluate(expr) = return expr.accept(self)

    def _execute(stmt) = stmt.accept(self)

#    def _resolve(expr, depth) = @_locals

    def executeBlock(block, env, startAt)=
        previous = @_environment
        @_environment = env
        statements = block.statements()
        len = statements.length()
        for i in Range(ife(startAt < len, startAt, 0), len)=
            if @_raisedExceptions.isEmpty=
                stmt = statements.(i)
                @_execute(stmt)
            end else=
               # $rescue = nil

            end
            rescue ex=
                if ex is Yield=
                    block.yieldBlock(i + ife(ex.rethrown ? 0  = 1))
                    ex.raise()
                end
            end
        end
        @_environment = previous
    end

    def getGlobal(name) = return @_globals.getAt(0, name)

    def getEnvironment() = return @_environment

    def raiseException(ex) = @_raisedExceptions.push(ex)

    def newObject(immutable, props) = return props.clone(not immutable)

    def newArray(immutable, props)

@Override
  public SimiEnvironment getEnvironment() {
    return environment;
  }

  @Override
  public void raiseException(SimiException e) {
    raisedExceptions.push(e);
  }

  @Override
  public SimiObject newObject(boolean immutable, LinkedHashMap<String, SimiValue> props) {
    return SimiObjectImpl.fromMap(getObjectClass(), immutable, props);
  }

  @Override
  public SimiObject newArray(boolean immutable, ArrayList<SimiValue> props) {
    return SimiObjectImpl.fromArray(getObjectClass(), immutable, props);
  }

  @Override
  public SimiObject newInstance(SimiClass clazz, LinkedHashMap<String, SimiValue> props) {
    return SimiObjectImpl.instance((SimiClassImpl) clazz, props);
  }

  @Override
  public SimiValue visitBlockExpr(Expr.Block stmt, boolean newScope) {
    executeBlock(stmt, new Environment(environment), 0);
    return null;
  }

  @Override
  public Void visitBreakStmt(Stmt.Break stmt) {
    if (loopBlocks.isEmpty()) {
      Simi.error(stmt.name, "Break outside a loop!");
    }
    throw new Break();
  }

  @Override
  public Void visitClassStmt(Stmt.Class stmt) {
      String className = stmt.name.lexeme;
      boolean isBaseClass = isBaseClass(className);
      if (isBaseClass) {
          globals.define(className, null);
      } else {
          environment.define(className, null);
      }
      List<SimiClassImpl> superclasses = null;
      if (stmt.superclasses != null) {
        superclasses = new ArrayList<>();
        for (Expr superclass  = stmt.superclasses) {
            SimiObject clazz = evaluate(superclass).getObject();
            if (!(clazz instanceof SimiClassImpl)) {
                throw new RuntimeError(stmt.name, "Superclass must be a class.");
            }
            superclasses.add((SimiClassImpl) clazz);
        }
      } else if (!isBaseClass) {
          superclasses = Collections.singletonList(getObjectClass());
      }
      environment = new Environment(environment);
      environment.define(Constants.SUPER, new SimiClassImpl.SuperClassesList(superclasses));

      Map<String, SimiValue> constants = new HashMap<>();
      for (Expr.Assign constant  = stmt.constants) {
          String key = constant.name.lexeme;
          SimiValue value = evaluate(constant.value);
          constants.put(key, value);
      }

    Map<OverloadableFunction, SimiFunction> methods = new HashMap<>();
    for (Stmt.Function method  = stmt.methods) {
        String name = method.name.lexeme;
      SimiFunction function = new SimiFunction(method, environment,
          name.equals(Constants.INIT), method.block.isNative());
      methods.put(new OverloadableFunction(name, function.arity()), function);
    }

    SimiClassImpl klass = new SimiClassImpl(className, superclasses, constants, methods);

//    if (superclass != null) {
//      environment = environment.enclosing;
//    }

    if (isBaseClass) {
        globals.assign(stmt.name, new SimiValue.Object(klass), false);
    } else {
        environment.assign(stmt.name, new SimiValue.Object(klass), false);
    }
    return null;
  }

  @Override
  public Void visitContinueStmt(Stmt.Continue stmt) {
    if (loopBlocks.isEmpty()) {
      Simi.error(stmt.name, "Continue outside a loop!");
    }
    throw new Continue();
  }

  @Override
  public Void visitExpressionStmt(Stmt.Expression stmt) {
    evaluate(stmt.expression);
    return null; // [void]
  }

  @Override
  public SimiValue visitFunctionStmt(Stmt.Function stmt) {
    SimiFunction function = new SimiFunction(stmt, environment, false, stmt.block.isNative());
    SimiValue value = new SimiValue.Callable(function, stmt.name.lexeme, null);
    environment.define(stmt.name.lexeme, value);
    return value;
  }

  @Override
  public Object visitElsifStmt(Stmt.Elsif stmt) {
    if (isTruthy(evaluate(stmt.condition))) {
      BlockImpl block = this.environment.getOrAssignBlock(stmt, stmt.thenBranch, yieldedStmts);
      try {
        block.call(this, null, true);
      } catch (Return | Yield returnYield) {
        if (returnYield instanceof Return) {
          this.environment.endBlock(stmt, yieldedStmts);
        } else {
          putBlock(stmt, block);
        }
        throw returnYield;
      }
      this.environment.endBlock(stmt, yieldedStmts);
      return true;
    }
    return false;
  }
end
