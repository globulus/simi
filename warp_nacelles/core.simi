import native "Core"

class Object {
    native keys
    native values
    native zip
    native isEmpty
    native clear
    native iterate
    native lock

    native merge(with)

    fn isNotEmpty = not isEmpty()
    fn has(key) = key in keys()
}

class_ String

class_ List {
    native init
    native get(key)
    native set(key, value)
    native add(value)
    native addAll(from)
    native isEmpty
    native clear
    native iterate
}

class_ Function

class_ Class

class Exception {
    init(@message)
}
class TypeMismatchException is Exception {
    init {
        super.init("tme")
    }
}
class NilReferenceException is Exception
class IllegalArgumentException is Exception
class AbstractMethodException is Exception
class MutabilityLockException is Exception

Math _= [
    min = fn(a, b) = if (a < b) a else b,
    max = fn(a, b) = if (a > b) a else b
]

class Range {
    init(@from, @to) {
        @min = Math.min(from, to)
        @max = Math.max(from, to)
    }

    fn iterate() = Range.Iterator(self)

    fn has(o) = o >= min and o <= max

    class Iterator {
        init(@range) {
            @current = range.min
        }

        fn next() = if current <= range.max {
                @current += 1
                current - 1
            } else {
                nil
            }
    }
}

class_ Num {

    fn rangeTo(lim) = Range(@_, lim)

    fn rangeUntil(lim) = Range(@_, lim - 1)

    fn equals(o) = (o is Num and @_ == o._)

    fn matches(o) = if self == o {
        @_
    } else {
        nil
    }

    fn iterate = rangeTo(self).iterate()
}

class_ Stream {

    enum Op {
        WHERE, MAP
    }

    init(@src) {
        @ops = List()
    }

    fn where(predicate) {
        @ops += [op = Op.WHERE, arg = predicate]
        return self
    }

    fn map(transformation) {
        @ops += [op = Op.MAP, arg = transformation]
        return self
    }

    fn toMutableList {
        list = List()
        for item in src {
            dst = item
            for operation in ops {
                op = operation.op
                when op {
                    Op.WHERE {
                        if not operation.arg(dst) {
                            dst $= nil
                            break
                        }
                    }
                    Op.MAP {
                        dst $= operation.arg(dst)
                    }
                }
            }
            if dst != nil {
                list += dst
            }
        }
        return list
    }

    fn toList = toMutableList().lock()
}

class_ StreamMixin {
    fn where(predicate) = Stream(self).where(predicate).toList()
    fn map(transformation) = Stream(self).map(transformation).toList()
}

extend Object import StreamMixin
extend List import StreamMixin