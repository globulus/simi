import "./stdlib/File.simi"


### SCANNER

TokenType = Enum.of([
    "LEFT_PAREN",
    "RIGHT_PAREN",
    "LEFT_BRACKET",
    "RIGHT_BRACKET",
    "LEFT_BRACE",
    "RIGHT_BRACE",
    "COMMA",
    "DOT",
    "NEWLINE",
    "ID",
    "STRING",
    "NUMBER",
    "EOF"
])

class Token:
    def init(type, lexeme, literal, line): pass
    def toString(): "[\(@type.key), \(@lexeme), \(@literal), @\(@line)]"
end

class ScanException(Exception):
    def init(line, message):
        super.init("Scan exception @\(line ?? -1): \(message).")
    end
end

class Scanner:

    _NON_ID_CHARS = '()[]{},."'
    _WHITESPACE_CHARS = " \t\n"

    def init(source):
        @source = source
        @sourceLen = source.length()
        @tokens = $[]
        @start = 0
        @current = 0
        @line = 1
    end

    def scanTokens(addEof):
        while not @_isAtEnd():
            @start = @current
            @_scanToken()
        end
        if addEof: @tokens.append(Token(TokenType.EOF, "", nil, @line))
        return @tokens #
    end

    def _scanToken():
        c = @_advance()
        when c:
            "(": @_addToken(TokenType.LEFT_PAREN)
            ")": @_addToken(TokenType.RIGHT_PAREN)
            "[": @_addToken(TokenType.LEFT_BRACKET)
            "]": @_addToken(TokenType.RIGHT_BRACKET)
            "{": @_addToken(TokenType.LEFT_BRACE)
            "}": @_addToken(TokenType.RIGHT_BRACE)
            ",": @_addToken(TokenType.COMMA)
            ".": @_addToken(TokenType.DOT)
            "/": # Single line comments
                if @_match("/"):
                    while @_peek() != '\n' and not @_isAtEnd(): @_advance()
                end
            end
            "\n":
                @line = @line + 1
                @_addToken(TokenType.NEWLINE)
            end
            else:
                if @_isWhiteSpace(c): pass
                elsif @_isStringDelim(c): @_string(c)
                elsif @_isDigit(c): @_number()
                else: @_identifier()
            end
        end
    end

    def _identifier():
        while @_isValidId(@_peek()): @_advance()
        text = @source.substring(@start, @current)
        @_addToken(TokenType.ID, text)
    end

    def _number():
        while @_isDigit(@_peek()): @_advance()
        if @_peek()== "." and @_isDigit(@_peekNext()):
            @_advance()
            while @_isDigit(@_peek()): @_advance()
        end
        @_addToken(TokenType.NUMBER, @source.substring(@start, @current).toNumber())
    end

    def _string(opener):
        while @_peek() != opener and not @_isAtEnd():
            if @_peek()== "\n": @line = @line + 1
            @_advance()
        end
        if @_isAtEnd():
            @_error(@line, "Unterminated string")
            return
        end
        @_advance()
        value = @_escapedString(@start + 1, @current - 1)
        @_addToken(TokenType.STRING, value)
    end

    def _escapedString(start, stop):
        return @source.substring(start, stop) #.replacing("\\n", "\n").replacing("\\t", "\t")
    end

    def _match(expected):
        if @_isAtEnd(): return false
        if @_peek() != expected: return false
        @current = @current + 1
        return true
    end

    def _peek():
        if @_isAtEnd(): return '\0'
        return @source.(@current)
    end

    def _peekNext():
        if @current + 1 >= @sourceLen: return '\0'
        return @source.(@current + 1)
    end

    def _isAlpha(c): c.isAlpha() or c == "_" or c == "$"

    def _isDigit(c): c.isDigit()

    def _isValidId(c): not @_isWhiteSpace(c) and c not in @_NON_ID_CHARS

    def _isStringDelim(c): c == '"'

    def _isWhiteSpace(c): c in @_WHITESPACE_CHARS

    def _isAtEnd(): return @current >= @sourceLen

    def _advance():
        @current = @current + 1
        return @source.(@current - 1)
    end

    def _addToken(type): @_addToken(type, nil)

    def _addToken(type, literal):
        text = @source.substring(@start, @current)
        @tokens.append(Token(type, text, literal, @line))
    end

    def _error(line, str): ScanException(line, str).raise()
end

### PARSER

class CodePiece:
    def toCode(): pass
end

class Value(CodePiece):
    def eval(args): pass
end

class Num(Value):
    def init(value is Number): pass
    def eval(args): @value
    def toCode(): @value.toString()
end

class Str(Value):
    def init(value is String): pass
    def eval(args): @value
    def toCode(): '"' + @value + '"'
    def toString(): @toCode()
end

class Symbol(Value):
    def init(value is String): pass
    def eval(args): @value
    def toCode(): @value
    def toString(): @toCode()
end

class Type(Value):
    def init(receiver is Symbol, args is List, value is Type): pass
    def init(value):
        if value == nil or (value is not Symbol and value is not List):
            IllegalArgumentException("Type return value must be a symbol or a list!").raise()
        end
        @value = value
    end
    def eval(args):
        sb = String.builder()
        if @receiver: sb.add(@receiver.toCode()).add(".")
        if @receiver == nil and @args == nil and @value != nil: sb.add(@value.toCode())
        else:
            sb.add("{")
            if @args: sb.add(@args.toCode())
            if @value: sb.add(@value.toCode())
            sb.add("}")
        end
        return sb.build()
    end
    def toCode(): @eval(nil)
    def toString(): @toCode()

    def isTypeOf(value): # Checks if provided value is of this type
        when value:
            is Num: return @value == Num
            is Str: return @value == Str
            is Symbol: return @value == Symbol
            is Type: pass # TODO what to do here?
            is List:
                # TODO
            end
            is Block:
               # TODO
            end
            else: IllegalArgumentException("Unable to infer type of value \(value)").raise()
        end
    end
end

class Vararg(Type):
    def init(type): pass
    def eval(args): @type.eval(args) + "..."
end

class Property(CodePiece):
    def init(type is Type, symbol is Symbol, value is Value): pass
    def toCode():
        sb = String.builder()
        if @type: sb.add(@type.toCode()).add(" ")
        if @symbol: sb.add(@symbol.toCode())
        if @symbol and @value: sb.add(" ")
        if @value: sb.add(@value.toCode())
        return sb.build()
    end
    def toString(): @toCode()
end

class List(Value):
    def init(args is Object):
        if not args.every(:_0 is Property): IllegalArgumentException("List args must be of type Property!").raise()
        varargIndex = args.findIndex(:_0.type is Vararg)
        if varargIndex != nil and varargIndex != args.len() - 1: IllegalArgumentException("Vararg argument must be the last one in the list!").raise()
        @vararg = varargIndex != nil
        @args = args
    end

    EMPTY = List([])

    def eval(args): @args
    def toCode(): "[" + String.from(@args.map(:_0.toCode()), ", ") + "]"
    def toString(): @toCode()

    def matchesTypes(other):
        checklist = $[] # Checklist holds values as we go. All the properties must have a value at the end of the run.
        for arg in @args: checklist.(arg) = arg.value # Init the checklist
        for otherArg in other.args: # Go through all the provided args
            if otherArg.symbol: # Provided arg has a named argument
                arg = args.where(:_0.symbol == otherArg.symbol)
                if arg.type != # TODO
            end
        end
    end
end

class Block(Value):
    def init(args is List, body is Object):
        @args = args
        @body = body
        @env = $[]
        @closure = nil
        @lastLine = nil
        @lastClosure = nil
    end

    def eval(args): pass # TODO
    def toCode():
        addNewlines = @body.isntEmpty()
        sb = String.builder()
        sb.add("{")
        if @args: sb.add(@args.toCode())
        if addNewlines: sb.add("\n")
        sb.add(String.from(@body.map(:_0.toCode()), "\n"))
        if addNewlines: sb.add("\n")
        sb.add("}")
        if addNewlines: sb.add("\n")
        return sb.build()
    end
    def toString(): @toCode()
end

class Call(Value): # The sole expression in Adam is a block invocation with args
    def init(op is Value, args is List): pass

    def eval(args): @op.eval(args)
    def toCode():
        sb = String.builder()
        sb.add(@op.toCode())
        if @args:
            argsCode = @args.toCode()
            sb.add("(").add(argsCode.substring(1, argsCode.len() - 1)).add(")")
        end
        return sb.build()
    end
    def toString(): @toCode()
end

class ParseException(Exception):
    def init(token, message):
        super.init("Parse exception @\(token): \(message).")
    end
end

class Parser:
    def init(tokens): pass

    def parse():
        @current = 0
        @typeTable = $[]
        @symbolTable = $[]
        exprs = $[]
        while not @_isAtEnd():
            exprs.push(@_expression(true))
        end
        return exprs
    end

    # Call syntax sugar rules:
    # 1. unary prefix operator - -a instead of -(a), doSomething withThis instead of doSomething(withThis)
    # 2. binary infix operator with receiver - a + b instead of a.+(b), this does that instead of this.does(that)

    def _expression(requiresNewline):
        @_matchAllNewlines()
        op = nil
        args = List.EMPTY
        if @_match(TokenType.STRING): op $= Str(@_previous().literal)
        elsif @_match(TokenType.NUMBER): op $= Num(@_previous().literal)
        else:
            op $= @_idOrBlock()
            if @_match(TokenType.LEFT_PAREN): args $= @_list(true)
        end
        if requiresNewline: @_consume(TokenType.NEWLINE, "Expected a newline after an expression")
        return ife(args, :Call(op, args), op)
    end

    def _idOrBlock():
        if @_match(TokenType.LEFT_BRACE): return @_block()
        if @_match(TokenType.ID): return @_tokenToSymbol(@_previous())
        @_error(@_peek(), "Expected a block or an ID!")
    end

    def _block():
        list = nil
        body = $[]
        if @_match(TokenType.LEFT_BRACKET): list $= @_list(false)
        else: list $= List.EMPTY
        while true:
            @_matchAllNewlines()
            if @_match(TokenType.RIGHT_BRACE): break
            body.push(@_expression(false))
        end
        return Block(list, body)
    end

    def _list(isCall):
        args = $[]
        terminator = ife(isCall, TokenType.RIGHT_PAREN, TokenType.RIGHT_BRACKET)
        while true:
            @_matchAllNewlines()
            args.push(@_property(isCall, terminator))
            if @_match(terminator): break # end of arg list
            @_consume(TokenType.COMMA, "Expected , between list arguments")
        end
        return List(args)
    end

    def _property(isCall, terminator): # Type name[ default]
        type = nil
        name = nil
        value = nil
        if isCall:
           value $= @_expression(false)
           if @_nextTokenIsValue(terminator):
                name $= value
                value $= @_expression(false)
           end
        end
        else:
           type $= @_type()
           name $= @_consume(TokenType.ID, "Expected an ID for arg name")
           if @_nextTokenIsValue(terminator): value $= @_expression(false) # has default value
        end
        nameSymbol = @_tokenToSymbol(name)
        return Property(type, nameSymbol, value)
    end

    def _nextTokenIsValue(terminator):
        type = @_peek().type
        return type != TokenType.COMMA and type != terminator
    end

    def _type(): # Either an ID or a block definition
        type = nil
        if @_match(TokenType.ID):
            id = @_previous()
            if @_match(TokenType.DOT):
                if @_peekSequence([TokenType.DOT, TokenType.DOT]):
                    @_advance()
                    @_advance()
                    type $= Vararg(Type(@_tokenToSymbol(id)))
                end
                else: type $= @_blockDef(id)
            end
            else: type $= Type(@_tokenToSymbol(id))
        end
        elsif @_match(TokenType.LEFT_BRACKET): type $= Type(@_list(false))
        else: type $= @_blockDef(nil)
        typeKey = type.toString()
        cachedValue = @typeTable.(typeKey)
        if cachedValue: return cachedValue
        else:
            @typeTable.(typeKey) = type
            return type
        end
    end

    def _blockDef(receiver):
        @_consume(TokenType.LEFT_BRACE, "Expected { for block def start")
        args = nil
        value = nil
        if @_match(TokenType.LEFT_BRACKET): args $= @_list(false)
        if @_peek().type != TokenType.RIGHT_BRACE: value $= @_type()
        @_consume(TokenType.RIGHT_BRACE, "Expected } for block def end")
        return Type(@_tokenToSymbol(receiver), args, @_tokenToSymbol(value))
    end

     def _matchAllNewlines():
        while @_match(TokenType.NEWLINE): pass
     end

     def _match(types):
         if types is Object:
             for type in types:
                 if @_matchOne(type): return true
             end
             return false
         end
         return @_matchOne(types)
     end

     def _matchOne(type):
         if @_check(type):
             @_advance()
             return true
         end
         return false
     end

     def _consume(type, message):
         if @_check(type): return @_advance()
         @_error(@_peek(), message)
     end

     def _check(type):
         if @_isAtEnd(): return false
         return @_peek().type == type
     end

     def _advance():
         if not @_isAtEnd(): @current = @current + 1
         return @_previous()
     end

     def _isAtEnd(): return @_peek().type == TokenType.EOF

     def _peek(): return @tokens.(@current)

     def _peekSequence(types):
         if @current + types.length() >= @tokens.length(): return false
         for i in types.length().times():
             if (@tokens.(@current + i)).type != types.(i): return false
         end
         return true
     end

     def _previous(): return @tokens.(@current - 1)

     def _tokenToSymbol(token):
        if token is not Token: return nil
        symbol $= Symbol(token.literal)
        symbolKey = symbol.toString()
        cachedValue = @symbolTable.(symbolKey)
        if cachedValue: return cachedValue
        else:
            @symbolTable.(symbolKey) = symbol
            return symbol
        end
    end

     def _error(token, message): ParseException(token, message).raise()
end

class Interpreter:
    def init(exprs): pass

    def interpret():

    end

    class NativeBlock(Block):

    end
end

### MAIN SCRIPT

source = File.readString("adamtest.adam")
scanner = Scanner(source)
tokens = scanner.scanTokens(true)
parser = Parser(tokens)
exprs = parser.parse()
print exprs
print parser.typeTable
print parser.symbolTable
interpreter = Interpreter(exprs)
interpreter.interpret()