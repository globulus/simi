import "./stdlib/File.simi"


### SCANNER

TokenType = Enum.of([
    "LEFT_PAREN",
    "RIGHT_PAREN",
    "LEFT_BRACKET",
    "RIGHT_BRACKET",
    "LEFT_BRACE",
    "RIGHT_BRACE",
    "COMMA",
    "DOT",
    "NEWLINE",
    "ID",
    "STRING",
    "NUMBER",
    "EOF"
])

class Token:
    def init(type, lexeme, literal, line): pass
    def toString(): "[\(@type.key), \(@lexeme), \(@literal), @\(@line)]"
end

class ScanException(Exception):
    def init(line, message):
        super.init("Scan exception @\(line ?? -1): \(message).")
    end
end

class Scanner:

    _NON_ID_CHARS = '()[]{},."'
    _WHITESPACE_CHARS = " \t\n"

    def init(source):
        @source = source
        @sourceLen = source.length()
        @tokens = $[]
        @start = 0
        @current = 0
        @line = 1
    end

    def scanTokens(addEof):
        while not @_isAtEnd():
            @start = @current
            @_scanToken()
        end
        if addEof: @tokens.append(Token(TokenType.EOF, "", nil, @line))
        return @tokens #
    end

    def _scanToken():
        c = @_advance()
        when c:
            "(": @_addToken(TokenType.LEFT_PAREN)
            ")": @_addToken(TokenType.RIGHT_PAREN)
            "[": @_addToken(TokenType.LEFT_BRACKET)
            "]": @_addToken(TokenType.RIGHT_BRACKET)
            "{": @_addToken(TokenType.LEFT_BRACE)
            "}": @_addToken(TokenType.RIGHT_BRACE)
            ",": @_addToken(TokenType.COMMA)
            ".": @_addToken(TokenType.DOT)
            "\n":
                @line = @line + 1
                @_addToken(TokenType.NEWLINE)
            end
            else:
                if @_isWhiteSpace(c): pass
                elsif @_isStringDelim(c): @_string(c)
                elsif @_isDigit(c): @_number()
                else:
                    if c == "/": # Single line comments
                        if @_match("/"):
                            while @_peek() != '\n' and not @_isAtEnd(): @_advance()
                            return
                        end
                    end
                    @_identifier()
                end
            end
        end
    end

    def _identifier():
        while @_isValidId(@_peek()): @_advance()
        text = @source.substring(@start, @current)
        @_addToken(TokenType.ID, text)
    end

    def _number():
        while @_isDigit(@_peek()): @_advance()
        if @_peek()== "." and @_isDigit(@_peekNext()):
            @_advance()
            while @_isDigit(@_peek()): @_advance()
        end
        @_addToken(TokenType.NUMBER, @source.substring(@start, @current).toNumber())
    end

    def _string(opener):
        while @_peek() != opener and not @_isAtEnd():
            if @_peek()== "\n": @line = @line + 1
            @_advance()
        end
        if @_isAtEnd():
            @_error(@line, "Unterminated string")
            return
        end
        @_advance()
        val = @_escapedString(@start + 1, @current - 1)
        @_addToken(TokenType.STRING, val)
    end

    def _escapedString(start, stop):
        return @source.substring(start, stop) #.replacing("\\n", "\n").replacing("\\t", "\t")
    end

    def _match(expected):
        if @_isAtEnd(): return false
        if @_peek() != expected: return false
        @current = @current + 1
        return true
    end

    def _peek():
        if @_isAtEnd(): return '\0'
        return @source.(@current)
    end

    def _peekNext():
        if @current + 1 >= @sourceLen: return '\0'
        return @source.(@current + 1)
    end

    def _isAlpha(c): c.isAlpha() or c == "_" or c == "$"

    def _isDigit(c): c.isDigit()

    def _isValidId(c): not @_isWhiteSpace(c) and c not in @_NON_ID_CHARS

    def _isStringDelim(c): c == '"'

    def _isWhiteSpace(c): c in @_WHITESPACE_CHARS

    def _isAtEnd(): return @current >= @sourceLen

    def _advance():
        @current = @current + 1
        return @source.(@current - 1)
    end

    def _addToken(type): @_addToken(type, nil)

    def _addToken(type, literal):
        text = @source.substring(@start, @current)
        @tokens.append(Token(type, text, literal, @line))
    end

    def _error(line, str): ScanException(line, str).raise()
end

### PARSER

class CodePiece:
    def toCode(): pass
end

class Value(CodePiece):
    def eval(args): pass
end

class Num(Value):
    def init(val is Number): pass
    def eval(args): @val
    def toCode(): @val.toString()
end

class Str(Value):
    def init(val is String): pass
    def eval(args): @val
    def toCode(): '"' + @val + '"'
    def toString(): @toCode()
end

class Symbol(Value):
    def init(val is String): pass
    def eval(args): @val
    def toCode(): @val
    def toString(): @toCode()
    def matches(other): @val == other.val
end

class Type(Value):
    def init(rec is Symbol, args is List, val is Type): pass
    def init(val):
        if val == nil or (val is not Symbol and val is not List):
            IllegalArgumentException("Type return val must be a symbol or a list!").raise()
        end
        @val = val
    end
    def eval(args):
        sb = String.builder()
        if @rec: sb.add(@rec.toCode()).add(".")
        if @rec == nil and @args == nil and @val != nil: sb.add(@val.toCode())
        else:
            sb.add("{")
            if @args: sb.add(@args.toCode())
            if @val: sb.add(@val.toCode())
            sb.add("}")
        end
        return sb.build()
    end
    def toCode(): @eval(nil)
    def toString(): @toCode()

    def isTypeOf(val): # Checks if provided val is of this type
        when val:
            is Num: return @val == Num
            is Str: return @val == Str
            is Symbol: return @val == Symbol
            is Type: return self == val
            is List: return @val.matches(val)
            is Block:
               # TODO
            end
            else: IllegalArgumentException("Unable to infer type of val \(val)").raise()
        end
    end
end

class Vararg(Type):
    def init(type): pass
    def eval(args): @type.eval(args) + "..."
end

class Property(Value):
    def init(type is Type, symbol is Symbol, val is Value): pass
    def eval(args):
        if not @val: UnsupportedOperationException("Unable to evaluate this property: \(self)").raise()
        return @val.eval(args)
    end
    def toCode():
        sb = String.builder()
        if @type: sb.add(@type.toCode()).add(" ")
        if @symbol: sb.add(@symbol.toCode())
        if @symbol and @val: sb.add(" ")
        if @val: sb.add(@val.toCode())
        return sb.build()
    end
    def toString(): @toCode()
end

class ListMismatchException(Exception)

class List(Value):
    def init(args is Object):
        if not args.every(:_0 is Property): IllegalArgumentException("List args must be of type Property!").raise()
        varargIndex = args.findIndex(:_0.type is Vararg)
        if varargIndex != nil and varargIndex != args.len() - 1: IllegalArgumentException("Vararg argument must be the last one in the list!").raise()
        @vararg = varargIndex != nil
        @args = args
    end

    def eval(args): @args
    def toCode(): "[" + String.from(@args.map(:_0.toCode()), ", ") + "]"
    def toString(): @toCode()
    def iterate(): @args.iterate()

    def type(): Type(self)
    def get(symbol is Symbol):
        arg = @args.where(:_0.symbol.matches(symbol)).first()
        if arg: return arg
        else: IllegalArgumentException("Unable to find arg with symbol \(symbol) in list: \(self)").raise()
    end

    def matchesTypes(other):
        checklist = $[] # Checklist holds vals as we go. All the properties must have a val at the end of the run.
        for arg in @args: checklist.(arg) = arg.val # Init the checklist
        for otherArg in other.args: # Go through all the provided args
            if otherArg.symbol: # Provided arg has a named argument
                arg = args.where(:_0.symbol == otherArg.symbol)
                if not arg.type.isTypeOf(otherArg.val): ListMismatchException("Types don't match").raise()
                checklist.(arg) = otherArg.val # If types match, copy the provided val
            end
        end
        if args.last() is Vararg:

        end
        else:

        end
    end
end

class UnassignedSymbolException(Exception):
    def init(symbol): super.init("Unable to find value for symbol: \(symbol.toCode())!")
end

class Environment:
    def init(parent is Environment):
        @parent = parent
        @depth = ife(parent, :parent.depth + 1, 0)
        @_props = $[]
    end

    def set(prop is Property): @_props.(prop.symbol) = prop
    def get(key is Symbol):
        env = self
        while env:
            value = @_props.(key)
            if value: return value
            else: env $= env.parent
        end
        UnassignedSymbolException().raise()
    end
end

class Block(Value):
    def init(guid is String, args is List, body is Object): pass
    def eval(args): pass # TODO
    def toCode():
        addNewlines = @body.isntEmpty()
        sb = String.builder()
        if @rec: sb.add(@rec.toCode()).add(".")
        sb.add("{")
        if @args: sb.add(@args.toCode())
        if addNewlines: sb.add("\n")
        sb.add(String.from(@body.map(:_0.toCode()), "\n"))
        if addNewlines: sb.add("\n")
        sb.add("}")
        if addNewlines: sb.add("\n")
        return sb.build()
    end
    def toString(): @toCode()
end

class Call(Value): # The sole expression in Adam is a block invocation with args
    def init(rec is Property, op is Property, args is List): pass

    def eval(args): @op.eval(args) # TODO add receiver
    def toCode():
        sb = String.builder()
        if @rec: sb.add(@rec.val.toCode()).add(".")
        sb.add(@op.val.toCode())
        if @args:
            argsCode = @args.toCode()
            sb.add("(").add(argsCode.substring(1, argsCode.len() - 1)).add(")")
        end
        return sb.build()
    end
    def toString(): @toCode()

    def isPrimitive(): not rec and not args # Primitive call is one that has no receiver nor args, meaning it's just a value
    def toValue():
        if @isPrimitive(): return @op
        else: UnsupportedOperationException("Unable to convert a non-primitive call to value: \(self)").raise()
    end
    def toProperty(): Property(nil, nil, @toValue())
    def toList(): List([@toProperty()])
end

class ParseException(Exception):
    def init(token, message):
        super.init("Parse exception @\(token): \(message).")
    end
end

class Parser:

    ListType = Enum.of(["ARG", "CALL", "RAW"])

    def init(tokens): pass

    def parse():
        @current = 0
        @typeTable = $[]
        @_addPrimitiveTypes()
        @symbolTable = $[]
        @symbolTypes = $[]
        @typeAliases = $[]
        @blockParents = $[]
        rootGuid = guid()

        exprs = $[]
        @_matchAllNewlines()
        while not @_isAtEnd():
            exprs.addAll(@_expressionLine(rootGuid))
            @_matchAllNewlines()
        end
        return exprs
    end

    def _addPrimitiveTypes():
        @_numType = @_cacheType(Type(Symbol("Num")))
        @_strType = @_cacheType(Type(Symbol("Str")))
        @_symbolType = @_cacheType(Type(Symbol("Symbol")))
    end

    # Purposely not using "statement" as expression line returns a value as well
    # An expression line is a desugaring candidate - multiple exprs on a single line
    # Raises an exception if desugaring doesn't work
    # Call syntax sugar rules:
    # 1. unary prefix operator - -a instead of -(a), doSomething withThis instead of doSomething(withThis)
    # 2. binary infix operator with rec - a + b instead of a.+(b), this does that instead of this.does(that)
    # 3. block outside parentheses if last param - do(this) { block } instead of do(this, { block })
    def _expressionLine(blockGuid):
        exprs = $[]
        while not @_match(TokenType.NEWLINE):
            @_checkTypedef(blockGuid)
            exprs.append(@_expression(blockGuid))
        end
        for expr in exprs: print "Returns: " + @_returnTypeOfCall(blockGuid, expr)
        # Desugaring phase
        # Find pairs of successive calls
        i = 1
        while i < exprs.len():
            e1 = exprs.(i - 1)
            e2 = exprs.(i)
            # TODO
            i += 2
        end
        if exprs == nil: return []
        return exprs
    end

    def _checkTypedef(blockGuid):
         if @_peek().literal == "def":
            @_advance()
            id = @_consume(TokenType.ID, "Need ID for typedef")
            type = @_type(blockGuid)
            @_consume(TokenType.NEWLINE, "Need newline after typedef")
            print "Set typealias for \(id.literal) as \(type)"
            @typeAliases.(@_implicitKey(id.literal)) = type
        end
    end

    def _expression(blockGuid):
        rec = nil
        op = nil
        args = nil

        if @_match(TokenType.STRING): op $= Property(@_strType, nil, Str(@_previous().literal))
        elsif @_match(TokenType.NUMBER): op $= Property(@_numType, nil, Num(@_previous().literal))
        elsif @_match(TokenType.ID): op $= @_symbolToProperty(@_tokenToSymbol(@_previous()))
        elsif @_match(TokenType.LEFT_BRACKET):
            list = @_list(blockGuid, @ListType.RAW)
            op $= Property(@_cacheType(list.type()), nil, list)
        end
        elsif @_match(TokenType.LEFT_BRACE):
            block = @_block(blockGuid)
            op $= Property(@_cacheType(@_typeOfBlock(blockGuid, block)), nil, block)
        end
        else: @_error(@_peek(), "Expected a value to start an expression!")

        # Automatically desugar assignment expressions to make building of Core easier
        # Assignment has internally highest priority
        if op.type.matches(@_symbolType) and @_peek().literal == "=":
            rec $= op
            op $= @_symbolToProperty(@_tokenToSymbol(@_advance()))
            args $= @_expression(blockGuid).toList()
            return Call(rec, op, args)
        end
        if @_match(TokenType.DOT):
            rec $= op
            op $= @_symbolToProperty(@_tokenToSymbol(@_consume(TokenType.ID, "Expected ID for a receiver call")))
        end
        if @_match(TokenType.LEFT_PAREN): args $= @_list(blockGuid, @ListType.CALL)
        call = Call(rec, op, args)
        return call
    end

    def _block(parentGuid):
        blockGuid = guid()
        @blockParents.(blockGuid) = parentGuid
        list = nil
        body = $[]

        if @_match(TokenType.LEFT_BRACKET): list $= @_list(blockGuid, @ListType.ARG)
        else: list $= nil
        for arg in list: @_putSymbolType(blockGuid, arg)

        if @_match(TokenType.NEWLINE): # Multi line body
            while not @_match(TokenType.RIGHT_BRACE):
                body.addAll(@_expressionLine(blockGuid))
                @_matchAllNewlines()
            end
        end
        elsif not @_match(TokenType.RIGHT_BRACE):
             body.append(@_expression(blockGuid))
             @_consume(TokenType.RIGHT_BRACE, "Expected } at end of block")
        end
        block = Block(blockGuid, list, body)
        return block
    end

    def _list(blockGuid, type):
        args = $[]
        terminator = ife(type == @ListType.CALL, TokenType.RIGHT_PAREN, TokenType.RIGHT_BRACKET)
        while true:
            @_matchAllNewlines()
            args.append(@_property(blockGuid, type, terminator))
            @_matchAllNewlines()
            if @_match(terminator): break # end of arg list
            @_consume(TokenType.COMMA, "Expected , between list arguments")
        end
        return List(args)
    end

    def _property(blockGuid, listType, terminator): # Type name[ default]
        type = nil
        name = nil
        val = nil
        if listType != @ListType.ARG:
           val $= @_expression(blockGuid)
           if @_nextTokenIsValue(terminator):
                name $= val
                val $= @_expression(blockGuid)
           end
        end
        else:
           type $= @_type(blockGuid)
           name $= @_consume(TokenType.ID, "Expected an ID for property name")
           if @_nextTokenIsValue(terminator): val $= @_expression(blockGuid) # has default val
        end
        nameSymbol = @_tokenToSymbol(name)
        return Property(type, nameSymbol, val)
    end

    def _nextTokenIsValue(terminator):
        type = @_peek().type
        return type != TokenType.COMMA and type != TokenType.NEWLINE and type != terminator
    end

    def _type(blockGuid): # Either an ID or a block definition
        type = nil
        if @_match(TokenType.ID):
            id = @_previous()
            if @_match(TokenType.DOT):
                if @_peekSequence([TokenType.DOT, TokenType.DOT]):
                    @_advance()
                    @_advance()
                    type $= Vararg(Type(@_tokenToSymbol(id)))
                end
                else: type $= @_blockDef(blockGuid, id)
            end
            else: type $= Type(@_tokenToSymbol(id))
        end
        elsif @_match(TokenType.LEFT_BRACKET): type $= Type(@_list(blockGuid, @ListType.ARG))
        else: type $= @_blockDef(blockGuid, nil)
        return @_cacheType(type)
    end

    def _blockDef(blockGuid, rec):
        @_consume(TokenType.LEFT_BRACE, "Expected { for block def start")
        args = nil
        val = nil
        if @_match(TokenType.LEFT_BRACKET): args $= @_list(blockGuid, @ListType.ARG)
        if @_peek().type != TokenType.RIGHT_BRACE: val $= @_type(blockGuid)
        @_consume(TokenType.RIGHT_BRACE, "Expected } for block def end")
        return Type(@_tokenToSymbol(rec), args, val)
    end

     def _matchAllNewlines():
        while @_match(TokenType.NEWLINE): pass
     end

     def _match(types):
         if types is Object:
             for type in types:
                 if @_matchOne(type): return true
             end
             return false
         end
         return @_matchOne(types)
     end

     def _matchOne(type):
         if @_check(type):
             @_advance()
             return true
         end
         return false
     end

     def _consume(type, message):
         if @_check(type): return @_advance()
         @_error(@_peek(), message)
     end

     def _check(type):
         if @_isAtEnd(): return false
         return @_peek().type == type
     end

     def _advance():
         if not @_isAtEnd(): @current = @current + 1
         return @_previous()
     end

     def _isAtEnd(): return @_peek().type == TokenType.EOF

     def _peek(): return @tokens.(@current)

     def _peekSequence(types):
         if @current + types.length() >= @tokens.length(): return false
         for i in types.length().times():
             if (@tokens.(@current + i)).type != types.(i): return false
         end
         return true
     end

     def _previous(): return @tokens.(@current - 1)

     def _tokenToSymbol(token):
        if token is not Token: return nil
        symbol $= Symbol(token.literal)
        symbolKey = @_implicitKey(symbol.toString())
        cachedValue = @symbolTable.(symbolKey)
        if cachedValue: return cachedValue
        else:
            @symbolTable.(symbolKey) = symbol
            return symbol
        end
    end

    def _symbolToProperty(symbol): Property(@_symbolType, nil, symbol)

    def _cacheType(type):
        typeKey = @_implicitKey(type.toString())
        cachedValue = @typeTable.(typeKey)
        if cachedValue: return cachedValue
        else:
            @typeTable.(typeKey) = type
            return type
        end
    end

    def _putSymbolType(blockGuid is String, prop is Property):
        key = @_implicitKey(prop.symbol.toString())
        symbolBlockTable = @symbolTypes.(key)
        if not symbolBlockTable:
            symbolBlockTable $= $[]
            @symbolTypes.(key) = symbolBlockTable
        end
        symbolBlockTable.(blockGuid) = prop.type
        print "Assigned type \(prop.type) to \(key)\" in \(blockGuid)"
    end

    def _getSymbolType(blockGuid is String, symbol is Symbol):
        symbolKey = @_implicitKey(symbol.toString())
        table = @symbolTypes.(symbolKey)
        currentBlock = blockGuid
        while currentBlock:
            type = table.(currentBlock)
            if type:
                print "Inferred type \(type) for \(symbol) in \(blockGuid)"
                return type
            end
            else: currentBlock $= @blockParents.(currentBlock) # Look up in parent environment
        end
        IllegalArgumentException("Attempt to infer type for undefined symbol: \(symbol)").raise()
    end

    def _typeOfBlock(blockGuid, block is Block): Type(nil, block.args, @_returnTypeOfCall(blockGuid, block.body.last()))

    def _returnTypeOfCall(blockGuid, call is Call):
        print "Inferring return type of \(call.toCode())"
        type = nil
        if call.rec:
            recType = call.rec.type
            if recType.matches(@_symbolType):
                print "Call rec is symbol, inferring type..."
                recType $= @_getSymbolType(blockGuid, call.rec.val)
            end
            opType = call.op.type
            if not opType.matches(@_symbolType): IllegalArgumentException("Op in receiver call must be a symbol!").raise()
#                print "Call op is not obviously a symbol, inferring type..."
#                opType $= @_typeOfBlock(blockGuid, call.op.val)
#                if not opType.matches(@_symbolType): IllegalArgumentException("Op in receiver call must be a symbol!").raise()
#            end
            if recType.val is not List:
                if recType.val is Symbol:
                    recType $= @typeAliases.(@_implicitKey(recType.val.toString()))
                    print "Rec type isn't obviously a list, checking aliases: \(recType)"
                end
                if recType.val is not List: IllegalArgumentException("Can't invoke receiver call on a non-list receiver: \(rec)").raise()
            end
            callee = recType.val.get(call.op.val)
            type $= callee.type
        end
        else:
            opType = call.op.type
            if opType.matches(@_symbolType):
                print "Call op is symbol, inferring type..."
                type $= @_getSymbolType(blockGuid, call.op.val)
            end
            else: type $= opType
        end
        return type.val
    end

    def _implicitKey(str): "#" + str

    def _error(token, message): ParseException(token, message).raise()
end

class Interpreter:
    def init(exprs):
        @exprs = exprs
        @env = Environment(nil)
    end

    def interpret():

    end

    def _initRootEnv():
    end
end

### MAIN SCRIPT

source = File.readString("adamtest.adam")
scanner = Scanner(source)
tokens = scanner.scanTokens(true)
parser = Parser(tokens)
exprs = parser.parse()
#print exprs
#print "All exprs are calls: " + exprs.every(:_0 is Call).bool()
#print parser.typeTable
#print parser.symbolTable
interpreter = Interpreter(exprs)
interpreter.interpret()