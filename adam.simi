import "./stdlib/File.simi"


### SCANNER

TokenType = Enum.of([
    "LEFT_PAREN",
    "RIGHT_PAREN",
    "LEFT_BRACKET",
    "RIGHT_BRACKET",
    "LEFT_BRACE",
    "RIGHT_BRACE",
    "COMMA",
    "DOT",
    "NEWLINE",
    "ID",
    "STRING",
    "NUMBER",
    "EOF"
])

class Token:
    def init(type, lexeme, literal, line): pass
    def toString(): "[\(@type.key), \(@lexeme), \(@literal), @\(@line)]"
end

class ScanException(Exception):
    def init(line, message):
        super.init("Scan exception @\(line ?? -1): \(message).")
    end
end

class Scanner:

    _NON_ID_CHARS = '()[]{},."'
    _WHITESPACE_CHARS = " \t\n"

    def init(source):
        @source = source
        @sourceLen = source.length()
        @tokens = $[]
        @start = 0
        @current = 0
        @line = 1
    end

    def scanTokens(addEof):
        while not @_isAtEnd():
            @start = @current
            @_scanToken()
        end
        if addEof: @tokens.append(Token(TokenType.EOF, "", nil, @line))
        return @tokens #
    end

    def _scanToken():
        c = @_advance()
        when c:
            "(": @_addToken(TokenType.LEFT_PAREN)
            ")": @_addToken(TokenType.RIGHT_PAREN)
            "[": @_addToken(TokenType.LEFT_BRACKET)
            "]": @_addToken(TokenType.RIGHT_BRACKET)
            "{": @_addToken(TokenType.LEFT_BRACE)
            "}": @_addToken(TokenType.RIGHT_BRACE)
            ",": @_addToken(TokenType.COMMA)
            ".": @_addToken(TokenType.DOT)
            "\n":
                @line = @line + 1
                @_addToken(TokenType.NEWLINE)
            end
            else:
                if @_isWhiteSpace(c): pass
                elsif @_isStringDelim(c): @_string(c)
                elsif @_isDigit(c): @_number()
                else:
                    if c == "/": # Single line comments
                        if @_match("/"):
                            while @_peek() != '\n' and not @_isAtEnd(): @_advance()
                            return
                        end
                    end
                    @_identifier()
                end
            end
        end
    end

    def _identifier():
        while @_isValidId(@_peek()): @_advance()
        text = @source.substring(@start, @current)
        @_addToken(TokenType.ID, text)
    end

    def _number():
        while @_isDigit(@_peek()): @_advance()
        if @_peek()== "." and @_isDigit(@_peekNext()):
            @_advance()
            while @_isDigit(@_peek()): @_advance()
        end
        @_addToken(TokenType.NUMBER, @source.substring(@start, @current).toNumber())
    end

    def _string(opener):
        while @_peek() != opener and not @_isAtEnd():
            if @_peek()== "\n": @line = @line + 1
            @_advance()
        end
        if @_isAtEnd():
            @_error(@line, "Unterminated string")
            return
        end
        @_advance()
        val = @_escapedString(@start + 1, @current - 1)
        @_addToken(TokenType.STRING, val)
    end

    def _escapedString(start, stop):
        return @source.substring(start, stop) #.replacing("\\n", "\n").replacing("\\t", "\t")
    end

    def _match(expected):
        if @_isAtEnd(): return false
        if @_peek() != expected: return false
        @current = @current + 1
        return true
    end

    def _peek():
        if @_isAtEnd(): return '\0'
        return @source.(@current)
    end

    def _peekNext():
        if @current + 1 >= @sourceLen: return '\0'
        return @source.(@current + 1)
    end

    def _isAlpha(c): c.isAlpha() or c == "_" or c == "$"

    def _isDigit(c): c.isDigit()

    def _isValidId(c): not @_isWhiteSpace(c) and c not in @_NON_ID_CHARS

    def _isStringDelim(c): c == '"'

    def _isWhiteSpace(c): c in @_WHITESPACE_CHARS

    def _isAtEnd(): return @current >= @sourceLen

    def _advance():
        @current = @current + 1
        return @source.(@current - 1)
    end

    def _addToken(type): @_addToken(type, nil)

    def _addToken(type, literal):
        text = @source.substring(@start, @current)
        @tokens.append(Token(type, text, literal, @line))
    end

    def _error(line, str): ScanException(line, str).raise()
end

### PARSER

class CodePiece:
    def toCode(): pass
end

class Value(CodePiece):
    def eval(args): pass
end

class Num(Value):
    def init(val is Number): pass
    def eval(args): @val
    def toCode(): @val.toString()
end

class Str(Value):
    def init(val is String): pass
    def eval(args): @val
    def toCode(): '"' + @val + '"'
    def toString(): @toCode()
end

class Symbol(Value):
    def init(val is String): pass
    def eval(args): @val
    def toCode(): @val
    def toString(): @toCode()
end

class Type(Value):
    def init(rec is Symbol, args is List, val is Type): pass
    def init(val):
        if val == nil or (val is not Symbol and val is not List):
            IllegalArgumentException("Type return val must be a symbol or a list!").raise()
        end
        @val = val
    end
    def eval(args):
        sb = String.builder()
        if @rec: sb.add(@rec.toCode()).add(".")
        if @rec == nil and @args == nil and @val != nil: sb.add(@val.toCode())
        else:
            sb.add("{")
            if @args: sb.add(@args.toCode())
            if @val: sb.add(@val.toCode())
            sb.add("}")
        end
        return sb.build()
    end
    def toCode(): @eval(nil)
    def toString(): @toCode()

    def isTypeOf(val): # Checks if provided val is of this type
        when val:
            is Num: return @val == Num
            is Str: return @val == Str
            is Symbol: return @val == Symbol
            is Type: return self == val
            is List: return @val.matches(val)
            is Block:
               # TODO
            end
            else: IllegalArgumentException("Unable to infer type of val \(val)").raise()
        end
    end
end

class Vararg(Type):
    def init(type): pass
    def eval(args): @type.eval(args) + "..."
end

class Property(CodePiece):
    def init(type is Type, symbol is Symbol, val is Value): pass
    def toCode():
        sb = String.builder()
        if @type: sb.add(@type.toCode()).add(" ")
        if @symbol: sb.add(@symbol.toCode())
        if @symbol and @val: sb.add(" ")
        if @val: sb.add(@val.toCode())
        return sb.build()
    end
    def toString(): @toCode()
end

class ListMismatchException(Exception)

class List(Value):
    def init(args is Object):
        if not args.every(:_0 is Property): IllegalArgumentException("List args must be of type Property!").raise()
        varargIndex = args.findIndex(:_0.type is Vararg)
        if varargIndex != nil and varargIndex != args.len() - 1: IllegalArgumentException("Vararg argument must be the last one in the list!").raise()
        @vararg = varargIndex != nil
        @args = args
    end

    EMPTY = List([])

    def eval(args): @args
    def toCode(): "[" + String.from(@args.map(:_0.toCode()), ", ") + "]"
    def toString(): @toCode()

    def matchesTypes(other):
        checklist = $[] # Checklist holds vals as we go. All the properties must have a val at the end of the run.
        for arg in @args: checklist.(arg) = arg.val # Init the checklist
        for otherArg in other.args: # Go through all the provided args
            if otherArg.symbol: # Provided arg has a named argument
                arg = args.where(:_0.symbol == otherArg.symbol)
                if not arg.type.isTypeOf(otherArg.val): ListMismatchException("Types don't match").raise()
                checklist.(arg) = otherArg.val # If types match, copy the provided val
            end
        end
        if args.last() is Vararg:

        end
        else:

        end
    end
end

class UnassignedSymbolException(Exception):
    def init(symbol): super.init("Unable to find value for symbol: \(symbol.toCode())!")
end

class Environment:
    def init(parent is Environment):
        @parent = parent
        @depth = ife(parent, :parent.depth + 1, 0)
        @_props = $[]
    end

    def set(prop is Property): @_props.(prop.symbol) = prop
    def get(key is Symbol):
        env = self
        while env:
            value = @_props.(key)
            if value: return value
            else: env $= env.parent
        end
        UnassignedSymbolException().raise()
    end
end

class Block(Value):
    def init(args is List, body is Object):
        @args = args
        @body = body
    end

    def eval(args): pass # TODO
    def toCode():
        addNewlines = @body.isntEmpty()
        sb = String.builder()
        if @rec: sb.add(@rec.toCode()).add(".")
        sb.add("{")
        if @args: sb.add(@args.toCode())
        if addNewlines: sb.add("\n")
        sb.add(String.from(@body.map(:_0.toCode()), "\n"))
        if addNewlines: sb.add("\n")
        sb.add("}")
        if addNewlines: sb.add("\n")
        return sb.build()
    end
    def toString(): @toCode()
end

class Call(Value): # The sole expression in Adam is a block invocation with args
    def init(rec is Value, op is Value, args is List): pass

    def eval(args): @op.eval(args)
    def toCode():
        sb = String.builder()
        if @rec: sb.add(@rec.toCode()).add(".")
        sb.add(@op.toCode())
        if @args:
            argsCode = @args.toCode()
            sb.add("(").add(argsCode.substring(1, argsCode.len() - 1)).add(")")
        end
        return sb.build()
    end
    def toString(): @toCode()

    def isPrimitive(): not rec and not args # Primitive call is one that has no receiver nor args, meaning it's just a value
    def toValue():
        if @isPrimitive(): return @op
        else: UnsupportedOperationException("Unable to convert a non-primitive call to value: \(self)").raise()
    end
    def toProperty(): Property(nil, nil, @toValue())
    def toList(): List([@toProperty()])
end

class ParseException(Exception):
    def init(token, message):
        super.init("Parse exception @\(token): \(message).")
    end
end

class Parser:
    def init(tokens): pass

    def parse():
        @current = 0
        @typeTable = $[]
        @symbolTable = $[]

        exprs = $[]
        @_matchAllNewlines()
        while not @_isAtEnd():
            line = @_expressionLine()
            exprs.addAll(line) # B
            @_matchAllNewlines()
        end
        return exprs
    end

    # Purposely not using "statement" as expression line returns a value as well
    # An expression line is a desugaring candidate - multiple exprs on a single line
    # Raises an exception if desugaring doesn't work
    def _expressionLine():
        exprs = $[]
        while not @_match(TokenType.NEWLINE):
            exprs.push(@_expression(false))
        end
        # Desugaring phase

        return exprs
    end

    # Call syntax sugar rules:
    # 1. unary prefix operator - -a instead of -(a), doSomething withThis instead of doSomething(withThis)
    # 2. binary infix operator with rec - a + b instead of a.+(b), this does that instead of this.does(that)
    # 3. block outside parentheses if last param - do(this) { block } instead of do(this, { block })

    def _expression(requiresNewline):
        rec = nil
        op = nil
        args = List.EMPTY
        if @_match(TokenType.STRING): op $= Str(@_previous().literal)
        elsif @_match(TokenType.NUMBER): op $= Num(@_previous().literal)
        else: op $= @_idOrBlock()

        # Automatically desugar assignment expressions to make building of Core easier
        # Assignment has internally highest priority
        if op is Symbol and @_peek().literal == "=":
            rec $= op
            op $= @_tokenToSymbol(@_advance())
            args $= @_expression(true).toList()
            return Call(rec, op, args)
        end

        if @_match(TokenType.DOT):
            rec $= op
            op $= @_tokenToSymbol(@_consume(TokenType.ID, "Expected ID for a receiver call"))
        end
        if @_match(TokenType.LEFT_PAREN): args $= @_list(true)
        call = Call(rec, op, args)
#        if requiresNewline:
#            sameLineExprs = $[call]
#            while not @_match(TokenType.NEWLINE):
#                nextExpr = @_expression(false)
#                sameLineExprs.push(nextExpr)
#            end
#            # Attempt desugaring
#            i = 0
#            while i < sameLineExprs.len():
#                e1 = sameLineExprs.(i)
#                sdfsdf
#            end
#
#            @_consume(TokenType.NEWLINE, "Expected a newline after an expression")
#
#        end
        return call
    end

    def _idOrBlock():
        if @_match(TokenType.LEFT_BRACE): return @_block()
        if @_match(TokenType.ID): return @_tokenToSymbol(@_previous())
        @_error(@_peek(), "Expected a block or an ID!")
    end

    def _block():
        list = nil
        body = $[]
        if @_match(TokenType.LEFT_BRACKET): list $= @_list(false)
        else: list $= List.EMPTY
        if @_match(TokenType.NEWLINE): # Multi line body
            while not @_match(TokenType.RIGHT_BRACE):
                body.addAll(@_expressionLine())
                @_matchAllNewlines()
            end
        end
        elsif not @_match(TokenType.RIGHT_BRACE):
             body.push(@_expression(false))
             @_consume(TokenType.RIGHT_BRACE, "Expected } at end of block")
        end
        return Block(list, body)
    end

    def _list(isCall):
        args = $[]
        terminator = ife(isCall, TokenType.RIGHT_PAREN, TokenType.RIGHT_BRACKET)
        while true:
            @_matchAllNewlines()
            args.push(@_property(isCall, terminator))
            if @_match(terminator): break # end of arg list
            @_consume(TokenType.COMMA, "Expected , between list arguments")
        end
        return List(args)
    end

    def _property(isCall, terminator): # Type name[ default]
        type = nil
        name = nil
        val = nil
        if isCall:
           val $= @_expression(false)
           if @_nextTokenIsValue(terminator):
                name $= val
                val $= @_expression(false)
           end
        end
        else:
           type $= @_type()
           name $= @_consume(TokenType.ID, "Expected an ID for arg name")
           if @_nextTokenIsValue(terminator): val $= @_expression(false) # has default val
        end
        nameSymbol = @_tokenToSymbol(name)
        return Property(type, nameSymbol, val)
    end

    def _nextTokenIsValue(terminator):
        type = @_peek().type
        return type != TokenType.COMMA and type != terminator
    end

    def _type(): # Either an ID or a block definition
        type = nil
        if @_match(TokenType.ID):
            id = @_previous()
            if @_match(TokenType.DOT):
                if @_peekSequence([TokenType.DOT, TokenType.DOT]):
                    @_advance()
                    @_advance()
                    type $= Vararg(Type(@_tokenToSymbol(id)))
                end
                else: type $= @_blockDef(id)
            end
            else: type $= Type(@_tokenToSymbol(id))
        end
        elsif @_match(TokenType.LEFT_BRACKET): type $= Type(@_list(false))
        else: type $= @_blockDef(nil)
        typeKey = "#" + type.toString()
        cachedValue = @typeTable.(typeKey)
        if cachedValue: return cachedValue
        else:
            @typeTable.(typeKey) = type
            return type
        end
    end

    def _blockDef(rec):
        @_consume(TokenType.LEFT_BRACE, "Expected { for block def start")
        args = nil
        val = nil
        if @_match(TokenType.LEFT_BRACKET): args $= @_list(false)
        if @_peek().type != TokenType.RIGHT_BRACE: val $= @_type()
        @_consume(TokenType.RIGHT_BRACE, "Expected } for block def end")
        return Type(@_tokenToSymbol(rec), args, val)
    end

     def _matchAllNewlines():
        while @_match(TokenType.NEWLINE): pass
     end

     def _match(types):
         if types is Object:
             for type in types:
                 if @_matchOne(type): return true
             end
             return false
         end
         return @_matchOne(types)
     end

     def _matchOne(type):
         if @_check(type):
             @_advance()
             return true
         end
         return false
     end

     def _consume(type, message):
         if @_check(type): return @_advance()
         @_error(@_peek(), message)
     end

     def _check(type):
         if @_isAtEnd(): return false
         return @_peek().type == type
     end

     def _advance():
         if not @_isAtEnd(): @current = @current + 1
         return @_previous()
     end

     def _isAtEnd(): return @_peek().type == TokenType.EOF

     def _peek(): return @tokens.(@current)

     def _peekSequence(types):
         if @current + types.length() >= @tokens.length(): return false
         for i in types.length().times():
             if (@tokens.(@current + i)).type != types.(i): return false
         end
         return true
     end

     def _previous(): return @tokens.(@current - 1)

     def _tokenToSymbol(token):
        if token is not Token: return nil
        symbol $= Symbol(token.literal)
        symbolKey = "#" + symbol.toString()
        cachedValue = @symbolTable.(symbolKey)
        if cachedValue: return cachedValue
        else:
            @symbolTable.(symbolKey) = symbol
            return symbol
        end
    end

     def _error(token, message): ParseException(token, message).raise()
end

class Interpreter:
    def init(exprs):
        @exprs = exprs
        @env = Environment(nil)
    end

    def interpret():

    end

    def _initRootEnv():
    end
end

### MAIN SCRIPT

source = File.readString("adamtest.adam")
scanner = Scanner(source)
tokens = scanner.scanTokens(true)
parser = Parser(tokens)
exprs = parser.parse()
print exprs
#print parser.typeTable
#print parser.symbolTable
interpreter = Interpreter(exprs)
interpreter.interpret()