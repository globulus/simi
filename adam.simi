import "./stdlib/File.simi"


### SCANNER

TokenType = Enum.of([
    "LEFT_PAREN",
    "RIGHT_PAREN",
    "LEFT_BRACKET",
    "RIGHT_BRACKET",
    "LEFT_BRACE",
    "RIGHT_BRACE",
    "LESS_THAN",
    "GREATER_THAN",
    "COMMA",
    "DOT",
    "NEWLINE",
    "ID",
    "STRING",
    "NUMBER",
    "EOF"
])

class Token:
    def init(type, lexeme, literal, line): pass
    def toString(): "[\(@type.key), \(@lexeme), \(@literal), @\(@line)]"
end

class ScanException(Exception):
    def init(line, message):
        super.init("Scan exception @\(line ?? -1): \(message).")
    end
end

class Scanner:

    _NON_ID_CHARS = '()[]{},."'
    _WHITESPACE_CHARS = " \t\n"

    def init(source):
        @source = source
        @sourceLen = source.length()
        @tokens = $[]
        @start = 0
        @current = 0
        @line = 1
        @_lessThanCount = 0 # We keep track of < tokens to decide which ones are generics delimiters and which are IDs
    end

    def scanTokens(addEof):
        while not @_isAtEnd():
            @start = @current
            @_scanToken()
        end
        if addEof: @tokens.append(Token(TokenType.EOF, "", nil, @line))
        return @tokens
    end

    def _scanToken():
        c = @_advance()
        when c:
            "(": @_addToken(TokenType.LEFT_PAREN)
            ")": @_addToken(TokenType.RIGHT_PAREN)
            "[": @_addToken(TokenType.LEFT_BRACKET)
            "]": @_addToken(TokenType.RIGHT_BRACKET)
            "{": @_addToken(TokenType.LEFT_BRACE)
            "}": @_addToken(TokenType.RIGHT_BRACE)
            ",": @_addToken(TokenType.COMMA)
            ".": @_addToken(TokenType.DOT)
            "\n":
                @line = @line + 1
                @_addToken(TokenType.NEWLINE)
            end
            else:
                if @_isWhiteSpace(c): pass
                elsif @_isStringDelim(c): @_string(c)
                elsif @_isDigit(c): @_number()
                else:
                    if c == "/": # Single line comments
                        if @_match("/"):
                            while @_peek() != '\n' and not @_isAtEnd(): @_advance()
                            return
                        end
                    end
                    @_identifier()
                end
            end
        end
    end

    def _identifier():
        while @_isValidId(@_peek()): @_advance()
        text = @source.substring(@start, @current)
        if not @_handleGenerics(text): @_addToken(TokenType.ID, text)
    end

    def _number():
        while @_isDigit(@_peek()): @_advance()
        if @_peek()== "." and @_isDigit(@_peekNext()):
            @_advance()
            while @_isDigit(@_peek()): @_advance()
        end
        @_addToken(TokenType.NUMBER, @source.substring(@start, @current).toNumber())
    end

    def _string(opener):
        while @_peek() != opener and not @_isAtEnd():
            if @_peek()== "\n": @line = @line + 1
            @_advance()
        end
        if @_isAtEnd():
            @_error(@line, "Unterminated string")
            return
        end
        @_advance()
        val = @_escapedString(@start + 1, @current - 1)
        @_addToken(TokenType.STRING, val)
    end

    def _escapedString(start, stop):
        return @source.substring(start, stop) #.replacing("\\n", "\n").replacing("\\t", "\t")
    end

    def _handleGenerics(text):
        if text.endsWith(">") and text.len() > 1:
            if text.startsWith("<"):
                @_addToken(TokenType.LESS_THAN)
                @_addToken(TokenType.ID, text.substring(1, text.len() - 1))
                @_addToken(TokenType.GREATER_THAN)
            end
            else: @_gensListOrId(text)
            return true
        end
        return false
    end

    def _gensListOrId(text): # Goes back to analyze if we had indeed a generics list
        i = @tokens.len() - 1
        foundGensList = false
        while i >= 0:
            token = @tokens.(i)
            if token.type == TokenType.ID:
                if @_tryLessThanSplit(token, i):
                    foundGensList $= true
                    break
                end
                else:
                    i -= 1
                    token $= @tokens.(i)
                end
            end
            if token.type != TokenType.COMMA: break
            i -= 1
            token $= @tokens.(i)
            if token.type != TokenType.ID: break
            if @_tryLessThanSplit(token, i):
                foundGensList $= true
                break
            end
            i -= 1
            token $= @tokens.(i)
            if token.type == TokenType.COMMA: continue
            if token.type != TokenType.ID: break
            if @_tryLessThanSplit(token, i):
                foundGensList $= true
                break
            end
        end
        if foundGensList:
            @_addToken(TokenType.ID, text.substring(0, text.len() - 1))
            @_addToken(TokenType.GREATER_THAN)
        end
        else: @_addToken(TokenType.ID, text)
    end

    def _tryLessThanSplit(token, i):
        if token.literal.startsWith("<"):
            @tokens.(i) = Token(TokenType.ID, nil, token.literal.substring(1), token.line)
            @tokens.insertAt(i, Token(TokenType.LESS_THAN, nil, "<", token.line))
            return true
        end
        return false
    end

    def _match(expected):
        if @_isAtEnd(): return false
        if @_peek() != expected: return false
        @current = @current + 1
        return true
    end

    def _peek():
        if @_isAtEnd(): return '\0'
        return @source.(@current)
    end

    def _peekNext():
        if @current + 1 >= @sourceLen: return '\0'
        return @source.(@current + 1)
    end

    def _isAlpha(c): c.isAlpha() or c == "_" or c == "$"

    def _isDigit(c): c.isDigit()

    def _isValidId(c): not @_isWhiteSpace(c) and c not in @_NON_ID_CHARS

    def _isStringDelim(c): c == '"'

    def _isWhiteSpace(c): c in @_WHITESPACE_CHARS

    def _isAtEnd(): return @current >= @sourceLen

    def _advance():
        @current = @current + 1
        return @source.(@current - 1)
    end

    def _addToken(type): @_addToken(type, nil)

    def _addToken(type, literal):
        text = @source.substring(@start, @current)
        @tokens.append(Token(type, text, literal, @line))
    end

    def _error(line, str): ScanException(line, str).raise()
end

### PARSER

class CodePiece:
    def toCode(): pass
end

class Value(CodePiece):
    def eval(args): pass
end

class Num(Value):
    def init(val is Number): pass
    def eval(args): @val
    def toCode(): @val.toString()
end

class Str(Value):
    def init(val is String): pass
    def eval(args): @val
    def toCode(): '"' + @val + '"'
    def toString(): @toCode()
end

class Symbol(Value):
    def init(val is String): pass
    def eval(args): @val
    def toCode(): @val
    def toString(): @toCode()
    def matches(other): @val == other.val
end

class Type(Value):
    def init(rec is Symbol, gens is List, args is List, val is Type): pass
    def init(val):
        if val is Type: val $= val.val # Destructure return type
        if val == nil or (val is not Symbol and val is not List and val is not Num and val is not Str):
            IllegalArgumentException("Type return val must be a primitive or a list!").raise()
        end
        @val = val
    end
    def eval(args):
        sb = String.builder()
        if @gens: sb.add(@gens.toCode())
        if @rec: sb.add(@rec.toCode()).add(".")
        if @rec == nil and @args == nil and @val != nil: sb.add(@val.toCode())
        else:
            sb.add("{")
            if @args: sb.add(@args.toCode())
            if @val: sb.add(@val.toCode())
            sb.add("}")
        end
        return sb.build()
    end
    def toCode(): @eval(nil)
    def toString(): @toCode()
    def matches(other): @toString() == other.toString()

    def hasGenType(genType is Type): @gens.any(:_0.symbol.matches(genType.val))

    def isTypeOf(val): # Checks if provided val is of this type
        when val:
            is Num: return @val == Num
            is Str: return @val == Str
            is Symbol: return @val == Symbol
            is Type: return self == val
            is List: return @val.matches(val)
            is Block:
               # TODO
            end
            else: IllegalArgumentException("Unable to infer type of val \(val)").raise()
        end
    end
end

class Vararg(Type):
    def init(type): pass
    def eval(args): @type.eval(args) + "..."
end

class Property(Value):
    def init(type is Type, symbol is Symbol, val is Value): pass
    def eval(args):
        if not @val: UnsupportedOperationException("Unable to evaluate this property: \(self)").raise()
        return @val.eval(args)
    end
    def toCode():
        sb = String.builder()
        if @type: sb.add(@type.toCode()).add(" ")
        if @symbol: sb.add(@symbol.toCode())
        if @symbol and @val: sb.add(" ")
        if @val: sb.add(@val.toCode())
        return sb.build()
    end
    def toString(): @toCode()
end

class ListMismatchException(Exception)

class List(Value):
    Type = Enum.of(["ARG", "CALL", "RAW", "GENS"])

    def init(type is List.Type, args is Object):
        if not args.every(:_0 is Property): IllegalArgumentException("List args must be of type Property!").raise()
        varargIndex = args.findIndex(:_0.type is Vararg)
        if varargIndex != nil and varargIndex != args.len() - 1: IllegalArgumentException("Vararg argument must be the last one in the list!").raise()
        @vararg = varargIndex != nil
        @args = args
        @type = type
    end

    def eval(args): @args
    def toCode():
        op = nil
        en = nil
        transformedArgs = @args
        if @type == @Type.CALL:
            op $= "("
            en $= ")"
            transformedArgs $= transformedArgs.map(:Property(nil, _0.op, _0.val))
        end
        elsif @type == @Type.GENS:
            op $= "<"
            en $= ">"
        end
        else:
            op $= "["
            en $= "]"
        end
        return op + String.from(transformedArgs.map(:_0.toCode()), ", ") + en
    end
    def toString(): @toCode()
    def iterate(): @args.iterate()
    def len(): @args.len()
    def plus(newArg): @args = @args.joined([newArg])

    def type(): Type(self)
    def get(symbol is Symbol):
        arg = @args.where(:_0.symbol.matches(symbol)).first()
        if arg: return arg
        else: IllegalArgumentException("Unable to find arg with symbol \(symbol) in list: \(self)").raise()
    end

    def matchesTypes(other):
        checklist = $[] # Checklist holds vals as we go. All the properties must have a val at the end of the run.
        for arg in @args: checklist.(arg) = arg.val # Init the checklist
        for otherArg in other.args: # Go through all the provided args
            if otherArg.symbol: # Provided arg has a named argument
                arg = args.where(:_0.symbol == otherArg.symbol)
                if not arg.type.isTypeOf(otherArg.val): ListMismatchException("Types don't match").raise()
                checklist.(arg) = otherArg.val # If types match, copy the provided val
            end
        end
        if args.last() is Vararg:

        end
        else:

        end
    end
end

class UnassignedSymbolException(Exception):
    def init(symbol): super.init("Unable to find value for symbol: \(symbol.toCode())!")
end

class Environment:
    def init(parent is Environment):
        @parent = parent
        @depth = ife(parent, :parent.depth + 1, 0)
        @_props = $[]
    end

    def set(prop is Property): @_props.(prop.symbol) = prop
    def get(key is Symbol):
        env = self
        while env:
            value = @_props.(key)
            if value: return value
            else: env $= env.parent
        end
        UnassignedSymbolException().raise()
    end
end

class Block(Value):
    def init(guid is String, args is List, body is Object): pass
    def eval(args): pass # TODO
    def toCode():
        addNewlines = @body.isntEmpty()
        sb = String.builder()
        if @rec: sb.add(@rec.toCode()).add(".")
        sb.add("{")
        if @args: sb.add(@args.toCode())
        if addNewlines: sb.add("\n")
        sb.add(String.from(@body.map(:_0.toCode()), "\n"))
        if addNewlines: sb.add("\n")
        sb.add("}")
        if addNewlines: sb.add("\n")
        return sb.build()
    end
    def toString(): @toCode()
end

class Call(Value): # The sole expression in Adam is a block invocation with args

    def init(rec is Property, op is Property, args is List, gensTable is Object): pass
    def init(rec, op, args): @init(rec, op, args, $[])

    def eval(args): @op.eval(args) # TODO add receiver
    def toCode():
        sb = String.builder()
        if @rec: sb.add(@rec.val.toCode()).add(".")
        sb.add(@op.val.toCode())
        if @args: sb.add(@args.toCode())
        elsif @rec: sb.add("()")
        return sb.build()
    end
    def toString(): @toCode() + ife(@gensTable.isntEmpty(), \
        " with <" + String.from(@gensTable.map(def (k, v): k + " = " + v).values(), ", ") + ">", "")

    def isPrimitive(): not rec and not args # Primitive call is one that has no receiver nor args, meaning it's just a value
    def toValue():
        if @isPrimitive(): return @op
        else: UnsupportedOperationException("Unable to convert a non-primitive call to value: \(self)").raise()
    end
    def toProperty(type): Property(type, nil, self)
    def toCallList(type): List(List.Type.CALL, [@toProperty(type)])
end

class ParseException(Exception):
    def init(token, message):
        super.init("Parse exception @\(token): \(message).")
    end
end

class UndefinedSymException(Exception):
    def init(sym is Symbol): super.init("Attempt to infer type for undefined symbol: \(sym)")
end

class Parser:

    def init(tokens):
        @tokens = tokens
        @current = 0
        @typeTable = $[]
        @_addPrimitiveTypes()
        @symbolTable = $[]
        @symbolTypes = $[]
        @typeAliases = $[]
        @blockParents = $[]
        rootGuid = guid()
    end

    def parse():
        exprs = $[]
        @_matchAllNewlines()
        while not @_isAtEnd():
            exprs.addAll(@_expressionLine(rootGuid))
            @_matchAllNewlines()
        end
        return exprs
    end

    def _addPrimitiveTypes():
        @_numType = @_cacheType(Type(Symbol("Num")))
        @_strType = @_cacheType(Type(Symbol("Str")))
        @_symbolType = @_cacheType(Type(Symbol("Symbol")))
    end

    # Purposely not using "statement" as expression line returns a value as well
    # An expression line is a desugaring candidate - multiple exprs on a single line
    # Raises an exception if desugaring doesn't work
    # Call syntax sugar rules:
    # 1. unary prefix operator with rec - -a instead of a.-(), doSomething withThis instead of withThis.doSomething()
    # 2. binary infix operator with rec - a + b instead of a.+(b), this does that instead of this.does(that)
    # 3. block outside parentheses if last param - do(this) { block } instead of do(this, { block })
    def _expressionLine(blockGuid):
        exprs = $[]
        while not @_match(TokenType.NEWLINE):
            if @_checkTypedef(blockGuid): continue
            exprs.append(@_expression(blockGuid))
        end
        print "Parsed on line " + exprs
        # Desugaring phase
        exprs $= @_desugarLastBlockParamPass(blockGuid, exprs)
        exprs $= @_desugarUnaryPass(blockGuid, exprs)
        exprs $= @_desugarBinaryPass(blockGuid, exprs)
        print "desugared " + exprs
        return exprs
    end

    def _desugarTwoOpPass(blockGuid, exprs, fun):
        len = exprs.len()
        if len == 1: return exprs
        desugared = $[]
        i = 1
        while i < len:
            e1 = exprs.(i - 1)
            e2 = exprs.(i)
            unaryAttempt = fun(blockGuid, desugared, e1, e2)
            if unaryAttempt:
                desugared.append(unaryAttempt)
                i += 1
            end
            else: desugared.append(e1)
            i += 1
            if i == len: desugared.append(e2)
        end
        return desugared
    end

    def _desugarUnaryPass(blockGuid, exprs): @_desugarTwoOpPass(blockGuid, exprs, def (b, d, e1, e2): @_desugarUnary(b, e1, e2))
    def _desugarLastBlockParamPass(blockGuid, exprs): @_desugarTwoOpPass(blockGuid, exprs, :@_desugarLastBlockParam(_0, _1.last(), _2, _3))

    def _desugarBinaryPass(blockGuid, exprs):
        len = exprs.len()
        if len < 3: return exprs
        desugared = $[]
        i = 2
        while i < len:
             e1 = exprs.(i - 2)
             e2 = exprs.(i - 1)
             e3 = exprs.(i)
             binaryAttempt = @_desugarBinary(blockGuid, e1, e2, e3)
             if binaryAttempt:
                desugared.append(binaryAttempt)
                i += 2
             end
             else: desugared.append(e1)
             i += 1
             if i == len:
                desugared.append(e2)
                desugared.append(e3)
             end
        end
        return desugared
    end

    def _desugarLastBlockParamPass(blockGuid, exprs):
        len = exprs.len()
        if len == 1: return exprs
        desugared = $[]
        i = 1
        while i < len:
            e0 = desugared.last()
            e1 = exprs.(i - 1)
            e2 = exprs.(i)
            unaryAttempt = @_desugarLastBlockParam(blockGuid, e0, e1, e2)
            if unaryAttempt:
                desugared.append(unaryAttempt)
                i += 1
            end
            else: desugared.append(e1)
            i += 1
            if i == len: desugared.append(e2)
        end
        return desugared
    end

    def _desugarUnary(blockGuid, e1, e2):
        print "Attempting unary desugar \(e1) \(e2)"
        if e1.op.val is Symbol:
            e2Type = @_listOrListAlias(@_returnTypeOfCall(blockGuid, e2))
            rescue ex:
                if ex: print "Silenced unary exception: \(ex.message)"
            end
            if e2Type.val is not List:
                print "E2 isn't a list but \(e2Type), bailing"
                return nil
            end
            member = e2Type.val.get(e1.op.val)
            if not member:
                print "Member not found for \(e1.op.val), bailing"
                return nil
            end
            memberType = member.type
            if memberType.args and memberType.args.isntEmpty():
                print "Member is a non-primitive block: \(member), bailing"
                return nil
            end
            print "Found primitive member \(member) on \(e2.op), returning desugar"
            print e2Type
            return Call(e2.op, e1.op, nil)
        end
        print "E1 isn't a symbol but \(e1.op), bailing"
        return nil
    end

    def _desugarBinary(blockGuid, e1, e2, e3):
        print "Attempting binary desugar \(e1) \(e2) \(e3)"
        if e2.op.val is Symbol:
            e1Type = @_listOrListAlias(@_returnTypeOfCall(blockGuid, e1))
            rescue ex:
                if ex: print "Silenced unary exception: \(ex.message)"
            end
            if e1Type.val is not List:
                print "E1 isn't a list but \(e1Type), bailing"
                return nil
            end
            member = e1Type.val.get(e2.op.val)
            if not member:
                print "Member not found for \(e2.op.val), bailing"
                return nil
            end
            memberType = member.type
            if memberType.args.len() != 1:
                print "Member is not a single arg block: \(member), bailing"
                return nil
            end
            e3Type = @_returnTypeOfCall(blockGuid, e3)
            rescue ex:
                if ex: print "Silenced unary exception: \(ex.message)"
            end
            firstArgType = memberType.args.args.0.type
            if not e3Type.matches(firstArgType):
                print "E3 type \(e3Type) doesn't match \(firstArgType), bailing"
                return nil
            end
            print "Binary desugar found"
            return Call(e1.toProperty(e1Type), e2.op, e3.toCallList(e3Type))
        end
        print "E2 isn't a symbol but \(e2.op), bailing"
        return nil
    end

    def _desugarLastBlockParam(blockGuid, e0, e1, e2):
        print "Attempting last block desugar \(e1) \(e2)"
        comboCandidate = false
        undefinedSymEx = nil
        if e2.op.val is Block:
            e1Type = @_typeOfCall(blockGuid, e1)
            rescue ex:
                if ex is UndefinedSymException:
                    print "\(ex.message) - found a combo binary candidate"
                    comboCandidate $= true
                    undefinedSymEx $= ex
                end
                else: ex.raise() # Rethrow as it's something we can't handle
            end
            if comboCandidate: # Combo candidate is a binary desugar on previously desugared member - if (a) { } else { }
                e0Type = @_listOrListAlias(@_returnTypeOfCall(blockGuid, e0))
                e0List = e0Type.val
                if e0List is not List:
                    if e0List.val is List:
                        e0List $= e0List.val
                    end
                    else:
                        print "E0 isn't a list but \(e0Type)"
                        undefinedSymEx.raise()
                    end
                end
                member = e0List.get(e1.op.val)
                if not member:
                    print "Member not found for \(e1.op.val), bailing"
                    undefinedSymEx.raise()
                end
                print "SO FAR SO GOOD"
                memberTypeWithoutGens = member.type
                if e0.gensTable:
                    memberTypeCode = memberTypeWithoutGens.toCode()
                    for [genKey, genVal] in e0.gensTable.zip():
                        gen = genKey.substring(1) # TODO move to a separate method
                        memberTypeCode $= memberTypeCode.replacing(gen, genVal.toString())
                    end
                    memberTypeWithoutGens $= Parser(Scanner(memberTypeCode).scanTokens(true))._type(blockGuid)
                end
                desugaredRightSide = @_desugarLastBlockParamWithKnownE1Type(blockGuid, e1, e2, memberTypeWithoutGens)
                if not desugaredRightSide: undefinedSymEx.raise()
                comboCall = Call(e0.toProperty(e0Type), desugaredRightSide.op, desugaredRightSide.args, e0.gensTable)
                print "Combo desugar found: \(comboCall)"
                return comboCall
            end
            return @_desugarLastBlockParamWithKnownE1Type(blockGuid, e1, e2, e1Type)
        end
        print "E2 isn't a block but \(e2.op), bailing"
        return nil
    end

    def _desugarLastBlockParamWithKnownE1Type(blockGuid, e1, e2, e1Type):
        if not e1Type.args:
            print "E1 type isn't a block call \(e1Type), bailing"
            return nil
        end
        if e1Type.args.len() != e1.args.len() + 1:
            print "E1 type isn't invoked with args len + 1, \(e1Type.args) vs \(e1.args), bailing"
            return nil
        end
        gensTable = $[]
        lastArgType = e1Type.args.args.last().type
        e2ReturnType = e2.op.type.val
        if not lastArgType.val.matches(e2ReturnType):
            if e1Type.hasGenType(lastArgType): # Check if maybe we're inferring a generic
                genKey = @_implicitKey(lastArgType)
                previousGen = gensTable.(genKey)
                if previousGen and not previousGen.matches(e2ReturnType):
                    print "Inferred type of \(e2ReturnType) collides with previously inferred generic \(genKey) whose value is \(previousGen)"
                    return nil
                end
                else:
                    print "Inferred generic type of \(e2ReturnType) for \(genKey)"
                    gensTable.(genKey) = e2ReturnType
                end
            end
            else:
                print "Last arg return type \(lastArgType.val) doesn't match E2 return type \(e2.op.type.val), bailing"
                return nil
            end
        end
        lastArgArgLen = lastArgType.args.len() ?? 0
        e2ArgLen = e2.op.args.len() ?? 0
        if e2ArgLen != 0 and e2ArgLen != lastArgArgLen:
            print "Last arg argument count of \(lastArgArgLen) doesn't match non-zero E2 arg len of \(e2ArgLen), bailing"
            return nil
        end
        print "Last block desugar found"
        return Call(e1.rec, e1.op, e1.args.plus(e2.op), gensTable)
    end

    def _checkTypedef(blockGuid):
         if @_peek().literal == "def":
            @_advance()
            id = @_consume(TokenType.ID, "Need ID for typedef")
            type = @_type(blockGuid)
            @_consume(TokenType.NEWLINE, "Need newline after typedef")
            print "Set type alias for \(id.literal) as \(type)"
            @typeAliases.(@_implicitKey(id.literal)) = type
            return true
        end
        return false
    end

    def _expression(blockGuid):
        rec = nil
        op = nil
        args = nil

        if @_match(TokenType.STRING): op $= Property(@_strType, nil, Str(@_previous().literal))
        elsif @_match(TokenType.NUMBER): op $= Property(@_numType, nil, Num(@_previous().literal))
        elsif @_match(TokenType.ID): op $= @_symbolToProperty(@_tokenToSymbol(@_previous()))
        elsif @_match(TokenType.LEFT_BRACKET):
            list = @_list(blockGuid, List.Type.RAW)
            op $= Property(@_cacheType(list.type()), nil, list)
        end
        elsif @_match(TokenType.LEFT_BRACE):
            block = @_block(blockGuid)
            op $= Property(@_cacheType(@_typeOfBlock(block.guid, block)), nil, block)
        end
        else: @_error(@_peek(), "Expected a value to start an expression!")

        # Automatically desugar assignment expressions to make building of Core easier
        # Assignment has internally highest priority
        if op.type.matches(@_symbolType) and @_peek().literal == "=":
            rec $= op
            op $= @_symbolToProperty(@_tokenToSymbol(@_advance()))
            args $= @_expressionLine(blockGuid)
            if args.len() != 1: @_error(@_peek(), "Invalid assignment expression \(rec) \(op) \(args)!")
            @current = @current - 1 # Backtrack so that we still have the NEWLINE in queue
            return Call(rec, op, args.first().toCallList(nil))
        end
        if @_match(TokenType.DOT):
            rec $= op
            op $= @_symbolToProperty(@_tokenToSymbol(@_consume(TokenType.ID, "Expected ID for a receiver call")))
        end
        if @_match(TokenType.LEFT_PAREN): args $= @_list(blockGuid, List.Type.CALL)
        call = Call(rec, op, args)
        return call
    end

    def _block(parentGuid):
        blockGuid = guid()
        @blockParents.(blockGuid) = parentGuid
        print "Analyzing block \(blockGuid) whose parent is \(parentGuid)"
        list = nil
        body = $[]

        if @_match(TokenType.LEFT_BRACKET): list $= @_list(blockGuid, List.Type.ARG)
        else: list $= nil
        for arg in list: @_putSymbolType(blockGuid, arg.symbol, arg.type)

        if @_match(TokenType.NEWLINE): # Multi line body
            while not @_match(TokenType.RIGHT_BRACE):
                body.addAll(@_expressionLine(blockGuid))
                @_matchAllNewlines()
            end
        end
        elsif not @_match(TokenType.RIGHT_BRACE):
             body.append(@_expression(blockGuid))
             @_consume(TokenType.RIGHT_BRACE, "Expected } at end of block")
        end
        block = Block(blockGuid, list, body)
        return block
    end

    def _list(blockGuid, type):
        args = $[]
        terminator = nil
        when type:
            List.Type.CALL: terminator $= TokenType.RIGHT_PAREN
            List.Type.GENS: terminator $= TokenType.GREATER_THAN
            else: terminator $= TokenType.RIGHT_BRACKET
        end
        while true:
            @_matchAllNewlines()
            args.append(@_property(blockGuid, type, terminator))
            @_matchAllNewlines()
            if @_match(terminator): break # end of arg list
            @_consume(TokenType.COMMA, "Expected , between list arguments")
        end
        return List(type, args)
    end

    def _property(blockGuid, listType, terminator): # Type name[ default]
        type = nil
        name = nil
        nameSymbol = nil
        val = nil
        when listType:
            List.Type.GENS:
                type $= @_type(blockGuid)
                if @_nextTokenIsValue(): name $= @_consume(TokenType.ID, "Expected an ID for property name")
                else: # It was just an ID without upper bound
                    nameSymbol $= type.val
                    type $= nil
                end
            end
            List.Type.ARG:
               type $= @_type(blockGuid)
               name $= @_consume(TokenType.ID, "Expected an ID for property name")
               if @_nextTokenIsValue(terminator): val $= @_expression(blockGuid) # has default val
            end
            else:
              val $= @_expression(blockGuid)
              if @_nextTokenIsValue(terminator):
                   name $= val
                   val $= @_expression(blockGuid)
              end
            end
        end
        if not nameSymbol: nameSymbol $= @_tokenToSymbol(name)
        return Property(type, nameSymbol, val)
    end

    def _nextTokenIsValue(terminator):
        type = @_peek().type
        return type != TokenType.COMMA and type != TokenType.NEWLINE and type != terminator
    end

    def _type(blockGuid): # Either an ID or a block definition
        type = nil
        if @_match(TokenType.ID):
            id = @_previous()
            if @_match(TokenType.DOT):
                if @_peekSequence([TokenType.DOT, TokenType.DOT]):
                    @_advance()
                    @_advance()
                    type $= Vararg(Type(@_tokenToSymbol(id)))
                end
                else: type $= @_blockDef(blockGuid, id)
            end
            else: type $= Type(@_tokenToSymbol(id))
        end
        elsif @_match(TokenType.LEFT_BRACKET): type $= Type(@_list(blockGuid, List.Type.ARG))
        else: type $= @_blockDef(blockGuid, nil)
        return @_cacheType(type)
    end

    def _blockDef(blockGuid, rec):
        gens = nil
        args = nil
        val = nil
        if @_match(TokenType.LESS_THAN): gens $= @_list(blockGuid, List.Type.GENS)
        if gens and not rec and @_peekSequence([TokenType.ID, TokenType.DOT]):
            rec $= @_advance()
            @_consume(TokenType.DOT, "This should never be printed")
        end
        if @_check(TokenType.LEFT_BRACKET): val $= @_type(blockGuid)
        else:
            @_consume(TokenType.LEFT_BRACE, "Expected { for block def start")
            if @_match(TokenType.LEFT_BRACKET): args $= @_list(blockGuid, List.Type.ARG)
            if not @_check(TokenType.RIGHT_BRACE): val $= @_type(blockGuid)
            if args and not val:
                print "Found a block def with args but no val: \(args). Switching them up..."
                val $= Type(args)
                args $= nil
            end
            @_consume(TokenType.RIGHT_BRACE, "Expected } for block def end")
        end
        return Type(@_tokenToSymbol(rec), gens, args, val)
    end

     def _matchAllNewlines():
        while @_match(TokenType.NEWLINE): pass
     end

     def _match(types):
         if types is Object:
             for type in types:
                 if @_matchOne(type): return true
             end
             return false
         end
         return @_matchOne(types)
     end

     def _matchOne(type):
         if @_check(type):
             @_advance()
             return true
         end
         return false
     end

     def _consume(type, message):
         if @_check(type): return @_advance()
         @_error(@_peek(), message)
     end

     def _check(type):
         if @_isAtEnd(): return false
         return @_peek().type == type
     end

     def _advance():
         if not @_isAtEnd(): @current = @current + 1
         return @_previous()
     end

     def _isAtEnd(): return @_peek().type == TokenType.EOF

     def _peek(): return @tokens.(@current)

     def _peekSequence(types):
         if @current + types.length() >= @tokens.length(): return false
         for i in types.length().times():
             if (@tokens.(@current + i)).type != types.(i): return false
         end
         return true
     end

     def _previous(): return @tokens.(@current - 1)

     def _tokenToSymbol(token):
        if token is not Token: return nil
        symbol $= Symbol(token.literal)
        symbolKey = @_implicitKey(symbol.toString())
        cachedValue = @symbolTable.(symbolKey)
        if cachedValue: return cachedValue
        else:
            @symbolTable.(symbolKey) = symbol
            return symbol
        end
    end

    def _symbolToProperty(symbol): Property(@_symbolType, nil, symbol)

    def _cacheType(type):
        typeKey = @_implicitKey(type.toString())
        cachedValue = @typeTable.(typeKey)
        if cachedValue: return cachedValue
        else:
            @typeTable.(typeKey) = type
            return type
        end
    end

    def _putSymbolType(blockGuid is String, symbol, type):
        key = @_implicitKey(symbol.toString())
        symbolBlockTable = @symbolTypes.(key)
        if not symbolBlockTable:
            symbolBlockTable $= $[]
            @symbolTypes.(key) = symbolBlockTable
        end
        symbolBlockTable.(blockGuid) = type
        print "Assigned type \(type) to \(key) in \(blockGuid)"
    end

    def _getSymbolType(blockGuid is String, symbol):
        symbolKey = @_implicitKey(symbol.toString())
        table = @symbolTypes.(symbolKey)
        currentBlock = blockGuid
        while currentBlock:
            type = table.(currentBlock)
            if type:
                print "Inferred type \(type) for \(symbol) in \(blockGuid)"
                return type
            end
            else: currentBlock $= @blockParents.(currentBlock) # Look up in parent environment
        end
        typeAlias = @typeAliases.(symbolKey)
        if typeAlias: return typeAlias
        if symbol is not Call:
            a = 5
            UndefinedSymException(symbol).raise()
        end
    end

    def _typeOfBlock(blockGuid, block is Block): Type(nil, nil, block.args, @_returnTypeOfCall(blockGuid, block.body.last()))

    def _typeOfCall(blockGuid, call is Call):
        type = nil
        if call.rec:
            recType = call.rec.type
            if recType.matches(@_symbolType):
                print "Call rec is symbol, inferring type..."
                recType $= @_getSymbolType(blockGuid, call.rec.val)
            end
            opType = call.op.type
            if not opType.matches(@_symbolType): IllegalArgumentException("Op in receiver call must be a symbol!").raise()
            recType $= @_listOrListAlias(recType)
            if recType.val is not List:
                a = 5 #BP
                IllegalArgumentException("Can't invoke receiver call on a non-list receiver: \(rec)").raise()
            end
            callee = recType.val.get(call.op.val)
            type $= callee
        end
        else:
            opType = call.op.type
            if opType.matches(@_symbolType):
                print "Call op is symbol, inferring type..."
                type $= @_getSymbolType(blockGuid, call.op.val)
            end
            else: type $= opType
        end
        return type
    end

    def _returnTypeOfCall(blockGuid, call is Call):
        print "Inferring return type of \(call.toCode())..."
        type = @_typeOfCall(blockGuid, call)
#        type = @_getSymbolType(blockGuid, call)
#        if type:
#            print "Found memoized return value of \(type)"
#            return type
#        end
       if call.rec: type $= type.type # Receiver calls have their return value a little deeper
        returnType = Type(type.val)
#        @_putSymbolType(blockGuid, call, returnType)
        print "...inferred \(returnType)"
        return returnType
    end

    def _listOrListAlias(type):
        if type.val is List: return type
        if type.val.val is List: return type.val
        return @typeAliases.(@_implicitKey(type.val.toString()))
    end

    def _implicitKey(str): "#" + str

    def _error(token, message): ParseException(token, message).raise()
end

class Interpreter:
    def init(exprs):
        @exprs = exprs
        @env = Environment(nil)
    end

    def interpret():

    end

    def _initRootEnv():
    end
end

### MAIN SCRIPT

source = File.readString("adamtest.adam")
scanner = Scanner(source)
tokens = scanner.scanTokens(true)
#print tokens
parser = Parser(tokens)
exprs = parser.parse()
#print exprs
#print "All exprs are calls: " + exprs.every(:_0 is Call).bool()
#print parser.typeTable
#print parser.symbolTable
interpreter = Interpreter(exprs)
interpreter.interpret()