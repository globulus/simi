import "./stdlib/Stdlib-java.jar"

class Actors {
  # Evaluates a function with self passed as param and returns its result. Can generally be used to map self
  # to something else, or to perform a nil check (as the function won't be called on a nil value).
  def let(f) = f(self)

  # Allows for quick init of object while returning self.
  def apply(f) {
     f(self)
     return self
  }

  # Used to add extra steps in chains, as the passed function is invoked with self, while self itself is returned
  # and not mutated.
  def also(f) {
      f$()
      return self
  }

   # Evaluates the associated block as if all the non-keyword lines refer to self
   # and as such is useful as a cleaner (but a lot slower) alternative to apply().
#   def with(block)=
#       import CodeBlocks
#       body = FunctionCode(block).body().map(def l=
#            tl = l.trim()
#            for keyword in CodeBlocks.KEYWORDS=
#                if tl.startsWith(keyword) = return l
#            }
#            return "@" + tl
#        })
#       fc = FunctionComposer(nil, nil)
#       fc.lines(body)
#       mutatedBlock = gu fc.getString()
#       mutatedBlock$()
#       return self
#   }
}

class Comparable {
    def compareTo(other) = native
}

class$ Object(in Actors, in Comparable) {
    def len() = native
    def keys() = native
    def values() = native
    def methods() = native
    def zip() = native # Returns array of (key, value) tuples for this object
    def ruler() = native # Accesses internal array associated with every object
    def className() = native # Name of this object's class

    def iterate() = native
    def has(obj) = native
    def equals(other) = native
    def toString() = native
    def matches(other) = native
    def matches(other, fields) = native

    def append(elem) = native
    def addAll(obj) = native
    def insertAt(loc, elem) = native
    def clear() = native

    def indexOf(elem) = native
    def reversed() = native
    def sorted() = native
    def sorted(comparator) = native
    def uniques() = native

    def clone() = native
    def clone(mutable) = native
    def isMutable() = native
    def isArray() = native
    def classObject() = native

    def array(capacity) = native
    def array(capacity, fillValue) = native
    def iterating(iterator) {
        buffer = $[]
        for item in iterator {
            buffer.append(item)
        }
        return buffer
    }
    def slice(start, stop) = native
    def builder() = native

    def length() = @len()
    def isEmpty() = @len() == 0
    def isntEmpty() = not @isEmpty()
    def first() = if @isEmpty() {
        nil
    } else {
        @0
    }
    def last() {
        len = @len()
        return if len == 0 {
            nil
        } else {
            @(len - 1)
        }
    }
    def setLast(newItem) = @(@len() - 1) = newItem
    def push(elem) = @append(elem)
    def every(predicate) {
        for item in self {
            if not predicate(item) {
                return false
            }
        }
        return true
    }
    def any(predicate) {
        for item in self {
            if predicate(item) {
                return true
            }
        }
        return false
    }
    def where(predicate) {
        buffer = $[]
        for item in self {
            if predicate(item) {
                buffer.append(item)
            }
        }
        return if @isArray() {
            buffer
        } else {
            buffer.zip()
        }
    }
    def find(predicate) {
        for item in self {
            if predicate(item) {
                return item
            }
        }
        return nil
    }
    def findIndex(predicate) {
        for [index, item] in @zip() {
            if predicate(item) {
                return index
            }
        }
        return nil
    }
    def count(predicate) = @where(predicate).len()
    def forEach(function) {
        for item in self {
            function(item)
        }
        return self
    }
    def joined(with) {
        clone = @clone()
        extra = with
        if with is not Object {
            extra $= [with]
        }
        clone.addAll(extra)
        return clone
    }
    def map(function) {
        if @isArray() {
             buffer = $[]
             for item in self {
                buffer.append(function(item))
            }
             return buffer
        } else {
            buffer = $[]
            for key in self {
                buffer.(key) = function(key, @(key))
            }
            return buffer
        }
    }
    def pop() {
        len = @len()
        return if len == 0 {
            nil
        } else {
            val = @(len - 1)
            @(len - 1) = nil
            val
        }
   }
   def reduce(initialValue, reducer) {
        val = initialValue
        for item in self {
            val $= reducer(val, item)
        }
        return val
   }
   def reduceRight(initialValue, reducer) = @reversed().reduce(initiaValue, reducer)
   def shift() = if @isEmpty() {
       nil
   } else {
       val = @0
       @0 = nil
       val
    }
   def removeIf(predicate) {
       for item in self.zip() {
           if predicate(item) {
                @(item.key) = nil
           }
       }
   }
   def slice(start) = @slice(start, @len())
   def randomItem() = @(Number.randomInt(@len()))

   def use(f) {
       f$()
   }
}

class_ Function

class Exception {
    def init(message) = pass

    def raise() = native
}

class ScannerException(Exception)

class ParserException(Exception)

class InterpreterException(Exception)

class NumberFormatException(Exception)

class NilReferenceException(Exception)

class IllegalArgumentException(Exception)

class UnsupportedOperationException(Exception)

class AbstractMethodException(Exception) {
    def init(method, sender) = @init("\(method) is abstract in \(sender.('class'))!")
}

def ife(condition, ifval, elseval) = if condition {
    ifval()
} else {
    elseval()
}

Io = [
    read = def = native,
    readNumber = =@read().toNumber(),
    scanf = def (format is String) {
        line = @read()
        tokens = String.builder()
        index = -1
        while (index $= format.indexOf('%', index + 1)) != nil {
            tokens.add(format.(index + 1))
        }
        tokens $= tokens.build()
        print tokens
    },

    printf = def (format is String, args) {
        print format.format(args)
    }
]

class Iterator {
    def next() = pass
}

class RangeIterator(Iterator) {
    def init(range) {
        @range = range
        @current = @range.start
    }

    def next() {
        if @current in @range {
            c = @current
            @current = @current + @range.step
            return c
        }
        return nil
    }
}

class Range {
    def init(start, stop) {
        @start = start
        @stop = stop
        @step = ife(start < stop, 1, -1)
    }

    def init(start, stop, step) = pass

    def iterate() = RangeIterator(self)

    def has(val) = if start < stop {
        val >= start and val < stop
    } else {
        val <= start and val > stop
    }

    def toString = String.builder()\
            .add("Range from ").add(start)\
            .add(" to ").add(stop)\
            .add(" by ").add(step)\
            .build()
}

class$ Number(in Actors, in Comparable) {
    def isInteger() = native

    def times() = ife(@_ < 0, =Range(@_, 0), =Range(0, @_)).iterate()
    def to(limit) = Range(@_, limit)
    def downto(limit) = Range(limit, @_)

    def randomInt(max) = native

   def equals(other) = native
   def toString() = native

    def sum(a, b) = a + b
    def product(a, b) = a * b

    def bitAnd(num) = native
    def bitOr(num) = native
    def bitXor(num) = native
    def bitInv() = native
    def bitShl(num) = native
    def bitShr(num) = native
    def bitUshr(num) = native

    def char() = native

    def bool() = ife(self, "true", "false")
}

class$ String(in Actors, in Comparable) {
   def len() = native
   def endsWith(suffix) = native
   def format(args) = native
   def indexOf(str, index) = native
   def lastIndexOf(str, index) = native
   def removing(start, stop) = native
   def replacing(old, new) = native
   def split(separator) = native
   def startsWith(prefix) = native
   def substring(start, stop) = native
   def lowerCased() = native
   def upperCased() = native
   def trim() = native
   def isAlpha() = native
   def isDigit() = native
   def unicode() = native

   def iterate() = native
   def has(obj) = native
   def equals(other) = native
   def toNumber() = native

   def builder() = native

    def sum(a, b) = a + b
    def from(array, separator) {
        if not array {
            return ""
        }
        first = true
        f = def (a, b) {
            s = ""
            if first {
                first $= false
            } else {
                s $= separator
            }
            return a + s + b
       }
       return array.reduce("", f)
    }

    def length() = @len()
    def indexOf(str) = @indexOf(str, 0)
    def lastIndexOf(str) = @lastIndexOf(str, @len() - 1)
    def removing(start) = @slice(start, @len())
    def substring(start) = @substring(start, @len())
    def isEmpty() = @len() == 0
    def isntEmpty() = not @isEmpty()
}

class TypeMismatchException(Exception) {
    def init(var, type) = super.init("Type mismatch exception = expected \(type.className()) but got \(var.className())!")
}

Math = [
    pow = def (a, b) = native,
    max = def (a, b) = native,
    min = def (a, b) = native,
    atan2 = def (a, b) = native,
    abs = def (a) = native,
    acos = def (a) = native,
    asin = def (a) = native,
    atan = def (a) = native,
    cbrt = def (a) = native,
    ceil = def (a) = native,
    cos = def (a) = native,
    cosh = def (a) = native,
    exp = def (a) = native,
    floor = def (a) = native,
    log = def (a) = native,
    log10 = def (a) = native,
    log1p = def (a) = native,
    logn = def (a, b) = @log(a) / @log(b),
    round = def (a) = native,
    signum = def (a) = native,
    sin = def (a) = native,
    sinh = def (a) = native,
    sqrt = def (a) = native,
    tan = def (a) = native,
    tanh = def (a) = native,
    toDegrees = def (a) = native,
    toRadians = def (a) = native
]

class Closeable {
    def close() = native
}

class Date {
    def init(timestamp) = pass

    def now() = native
    def format(pattern) = native
}

class Enum {
    def of(obj) = @of(obj, nil)

    def of(obj, funs) {
       if not obj or obj.isEmpty() {
            return nil
        }

        timestamp = clock().toString()
        joined = obj.reduce("", String.sum)
        className = "EnumClass" + joined + timestamp

        isArray = obj.isArray()
        isFirstValueScalar = obj.0 is not Object
        args = "value"
        if not isArray and not isFirstValueScalar {
            args $= String.from(obj.0, ", ")
        }
        args += ", key"

        guStr = "class$ \(className)(Enum) {
            def init(\(args)) = pass
            def equals(other) = @matches(other)
        }"
        clazz = gu guStr

        clazz.values = $[]
        for key in obj {
            val = if isArray {
                clazz(key, key)
            } elsif isFirstValueScalar {
                clazz(obj.(key), key)
            } else {
                args = String.from(obj.(key).values(), ", ")
                args += ", \(key)"
                constructor =  "clazz(" + args + ")"
                gu constructor
            }
            clazz.(key) = val
            clazz.values.append(val)
        }

        for key in funs {
            clazz.(key) = funs.(key)
        }

        clazz.iterate = =@values.iterate()

        return clazz
    }
}

class_ Debugger {
    def watcher() = native
}

Meta = [
    go = def (mutators, f) {
        mutated = f
        mutators.forEach(def m = mutated $= m.go($mutated))
        return mutated
    }
]
