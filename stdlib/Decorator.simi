import "./Stdlib/CodeBlocks.simi"

Decorator = [
    KEYWORD = "decorate *",

    go = def (f) {
        lines = (ivic f).split("\n")
        newLines = $[]
        decorators = nil
        skip = -1
        for e in lines.zip() {
            [i, line] = e
            trimmedLine = line.trim()
            if trimmedLine.startsWith(@KEYWORD) {
#                print trimmedLine.substring(@KEYWORD.len() + 1)
                 decorators $= (gu trimmedLine.substring(@KEYWORD.len() + 1)).split(", ")
#                print "Found decorators = " + decorators
            }
            elsif decorators and CodeBlocks.FunctionCode.isDefLine(trimmedLine) {
                func = CodeBlocks.FunctionCode(lines, i)
                params = func.parametersWithoutParentheses()
                newLines.append(line)
                tempName = @_tempName()
                newLines.append(tempName + " = def (" + params + ")=")
                newLines.addAll(func.body().map(def l = l.replacing(func.name + "(", tempName + "(")))
                newLines.append("}")
                str = String.builder().add("return ")
                for f in decorators {
                    str.add(f).add("(")
                }
                str.add(tempName)
                for _ in decorators.len().times() {
                    str.add(")")
                }
                needsBrackets = params.isEmpty() or "," in params
                str\
                    .add("(").add(ife(needsBrackets, "[", ""))\
                    .add(params)\
                    .add(ife(needsBrackets, "]", "")).add(")")
                newLines.append(str.build())
                decorators $= nil
                skip $= i + func.body().len()
            }
            elsif i > skip {
                newLines.append(line)
            }
        }
        tempName = @_tempName()
        print  "[" + tempName + " = " + String.from(newLines, "\n") + "\n]." + tempName
        return gu ("[" + tempName + " = " + String.from(newLines, "\n") + "\n]." + tempName)
    },

    _tempName = ="temp" + clock().toString().substring(5),

    test = def {
        @go(def {
            def timed(f) {
                wrapper = def args {
                    t1 = clock()
                    val = f(args)
                    print "It took " + (clock() - t1) + " ms to run"
                    return val
                }
                return wrapper
            }

            decorate* "timed"
            def printf(string, args) {
                print string.format(args)
            }

            decorate* "timed"
            def sum(n) {
                res = 0
                for i in n.times() {
                    res += i
                }
                return res
            }

            decorate* "timed"
            def exp(a, b) {
                res = 1
                for _ in b.times() {
                    res *= a
                }
                return res
            }

            printf("%.2f", [1.1111])
            print sum(10_000)
            print exp(2, 50)
        })()
    },

    timed = def f {
        wrapper = def args {
            t1 = clock()
            val = f(args)
            print "It took " + (clock() - t1) + " ms to run"
            return val
        }
        return wrapper
    },

    memoize = def f {
        fcache = $[]
        workerCache = $[]
        farg = nil
        fworker = def f {
            farg $= CodeBlocks.FunctionCode(f)
            return flooper()
        }
        flooper = def {
            while true {
                fname = farg.name
#                print "In flooper = " + fname
                if fname not in fcache {
                    workerLines = $[]
                    workerLines.append(farg.anonymousDeclaration().replacing("(", "(looper, "))
                    temp = 0
                    for line in farg.body() {
                        trimmedLine = line.trim()
                        if fname in trimmedLine {
                            parts = $[]
                            currentLine = trimmedLine
                            while fname in currentLine {
                                index = currentLine.indexOf(fname)
                                parts.append(currentLine.substring(0, index))
                                rest = $currentLine.substring(index)
                                parenCount = 0
                                firstParen = -1
                                for i in rest.len().times() {
                                    c = rest.(i)
                                    if c == '(' {
                                        if parenCount == 0 {
                                            firstParen $= i
                                        }
                                        parenCount += 1
                                    } elsif c == ')' {
                                        parenCount -= 1
                                        if parenCount == 0 {
                                            tempName = "temp" + temp
                                            temp += 1
                                            params $= rest.substring(firstParen, i + 1)
                                            if farg.arity != 1 {
                                                params $= "[" + params.substring(1, params.len() - 1) + "]"
                                            }
                                            workerLines.append("arg $= " + params)
                                            workerLines.append(tempName + " = looper()")
                                            parts.append(tempName)
                                            currentLine $= rest.substring(i + 1)
                                            break
                                        }
                                    }
                                }
                            }
#                                print parts
                            workerLines.append(String.from(parts, " "))
                        } else {
                            workerLines.append(line)
                        }
                    }
                    workerLines.append("}")
#                    print workerLines
                    workerCache.(fname) = gu ("[f = " + String.from(workerLines, "\n") + "].f")
                    fcache.(fname) = def args {
                        cache = $[]
                        arg = 0
                        worker = workerCache.(fname)
                        looper = def {
                           while true {
                            key = arg.toString()
                            if key not in cache {
                             cache.(key) = worker([looper].joined(arg))
                            }
#                            else = print "found key in cache = " + key
                            yield cache.(key)
                         }
                       }
                       return worker([looper].joined(args))
                    }
                }
                yield fcache.(fname)
            }
        }
        return fworker(f)
    }
]

#Decorator.test()
