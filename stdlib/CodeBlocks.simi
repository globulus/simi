class_ CodeBlocks {

    KEYWORDS = [
        "print"
    ] # TBC

    class InvalidBlockException(Exception)

    class_ ClassCode { # Can't be named Class because of the Class metaclass
        def init(c) {
            @ref = c
            code = c.toString() ?? ("" + c)
            firstLine = code.substring(0, code.indexOf('['))
            @name = firstLine.substring(0, firstLine.indexOf('(') ?? firstLine.indexOf(' = '))
        }
    }

    class_ ClassComposer {
        def init(name): @init(name, "")

        def init(name, type): @init(name, type, nil, nil)

        def init(name, type, superclasses, mixins) {
            @name = name
            @body = String.builder().add("class").add(type).add(" ").add(name)
            params = (superclasses ?? []).joined(mixins.map(def m: "in \(m)") ?? [])
            if params.isntEmpty(): @body.add("(").add(String.from(params, ", ")).add(")")
            @body.add(":\n")
        }

        def field(key, value): @body.add(key).add(" = ").add(ivic value).add("\n")

        def method(m): @body.add(ivic m).add("\n")

        def add(code): @body.add(code).add("\n")

        def getString() {
            @body.add("}")
            s = @body.build()
            @body = nil
            return s
        }

        def getClass(): gu @getString()
    }

    class_ FunctionComposer {
        def init(name is String, params is Object) {
            @_anonymous = name == nil
            @body = String.builder().add("def ").add(name ?? "").add("(").add(String.from(params, ", ")).add("):\n")
        }

        def fromFunc(f is Function, anonymous is Number) {
            @_anonymous = anonymous
            composer = FunctionComposer()
            fc = CodeBlocks.FunctionCode(f)
            composer.body = String.builder().add(ife(anonymous, :fc.anonymousDeclaration(), :fc.declaration())).add("\n")
            for line in fc.body(): composer.line(line)
            return composer
        }

        def line(line is String): @body.add("   ").add(line).add("\n")

        def lines(lines is Object): lines.forEach(def l: @line(l))

        def getString() {
            @body.add("}")
            s = @body.build()
            @body = nil
            return ife(@_anonymous, "(\(s))", s) # gu mandates that anon functions be enclosed in parentheses
        }

        def getFunction(): gu @getString()
    }

    class_ FunctionCode {

        _ANON_DEF = " = def"
        _BASIC_DEF = "def "

        def init(f) {
            @ref = f
            @name = "" + f
            @lines = (ivic f).split("\n")
            annotCount = 0
            for line in @lines {
                if line.trim().startsWith("!"): annotCount += 1
            }
            @annotCount = annotCount
            @_computeArity()
        }

        def init(lines, startLine) {
            defLine = (lines.(startLine)).trim()
            if not @isDefLine(defLine): CodeBlocks.InvalidBlockException("The start line isn't a def line!").raise()
            if @_ANON_DEF in defLine: @name = defLine.substring(0, defLine.indexOf(@_ANON_DEF))
            else: @name = defLine.substring(@_BASIC_DEF.len(), defLine.indexOf('('))
            fLines = $[]
            endCount = 0
            for i in Range(startLine, lines.len()) {
                line = lines.(i)
                fLines.append(line)
                trimmedLine = line.trim()
                if trimmedLine.endsWith(":"): endCount += 1
                elsif trimmedLine == "}" {
                    endCount -= 1
                    if endCount == 0: break
                }
            }
            @annotCount = 0
            @lines = fLines
            @_computeArity()
        }

        def declaration(): @lines.(@annotCount)
        def anonymousDeclaration(): @declaration().replacing(@name, "")
        def parametersWithoutParentheses() {
            trimmed = @declaration().trim()
            return trimmed.substring(trimmed.indexOf('(') + 1, trimmed.lastIndexOf(')'))
        }
        def parameters(): @parametersWithoutParentheses().split(", ")
        def body(): @lines.slice(@annotCount + 1, @lines.len() - 1)

        def isDefLine(line): return line.startsWith(@_BASIC_DEF) or @_ANON_DEF in line

        def _computeArity() {
            count = 0
            params = @parametersWithoutParentheses()
            if params.len() == 0 {
                @arity = 0
                return
            }
            for c in params {
                if c == ',': count += 1
            }
            @arity = count + 1
        }
    }
}
